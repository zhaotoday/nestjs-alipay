{"version":3,"file":"types.js","sourceRoot":"../","sources":["src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { EnumLocaleExtends } from 'enum-plus/extension';\n\nexport type { LocalizeInterface } from './localize-interface';\n\nexport type EnumItemLabel = EnumLocaleExtends['LocaleKeys'];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EnumInit<K extends keyof any = string, V extends EnumValue = EnumValue> =\n  | NumberEnumInit<K>\n  | StringEnumInit<K>\n  | StringNumberEnumInit<K>\n  | BooleanEnumInit<K>\n  | DateEnumInit<K>\n  | RegExpEnumInit<K>\n  | StandardEnumInit<K, V>\n  | ValueOnlyEnumInit<K, V>\n  | LabelOnlyEnumInit<K>\n  | MetaOnlyEnumInit<K>\n  | CompactEnumInit<K>\n  | OmitEnumInit<K>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type NumberEnumInit<K extends keyof any> = Record<K, number>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StringEnumInit<K extends keyof any> = Record<K, string>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StringNumberEnumInit<K extends keyof any> = Record<K, string | number>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type BooleanEnumInit<K extends keyof any> = Record<K, boolean>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DateEnumInit<K extends keyof any> = Record<K, Date>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type RegExpEnumInit<K extends keyof any> = Record<K, RegExp>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StandardEnumInit<K extends keyof any, V extends EnumValue> = Record<K, StandardEnumItemInit<V>>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ValueOnlyEnumInit<K extends keyof any, V extends EnumValue> = Record<K, ValueOnlyEnumItemInit<V>>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LabelOnlyEnumInit<K extends keyof any> = Record<K, LabelOnlyEnumItemInit>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type MetaOnlyEnumInit<K extends keyof any> = Record<K, MetaOnlyEnumItemInit>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type CompactEnumInit<K extends keyof any> = Record<K, CompactEnumItemInit>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OmitEnumInit<K extends keyof any> = Record<K, undefined>;\n\nexport type EnumItemInit<V extends EnumValue = EnumValue> =\n  | EnumValue\n  | StandardEnumItemInit<V>\n  | ValueOnlyEnumItemInit<V>\n  | LabelOnlyEnumItemInit\n  | MetaOnlyEnumItemInit\n  | CompactEnumItemInit\n  | undefined;\nexport interface StandardEnumItemInit<V extends EnumValue> {\n  value: V;\n  label: EnumItemLabel;\n}\nexport interface ValueOnlyEnumItemInit<V extends EnumValue> {\n  value: V;\n  label?: never;\n}\nexport interface LabelOnlyEnumItemInit {\n  label: EnumItemLabel;\n  value?: never;\n}\nexport interface MetaOnlyEnumItemInit {\n  value?: never;\n  label?: never;\n  [meta: string]: unknown;\n}\nexport type CompactEnumItemInit = Record<string, never>; // equivalent to {}\n\n/**\n * - **EN:** Data structure of enumeration item options, used in `toList` method\n * - **CN:** 枚举项选项的数据结构，用于`toList`方法\n *\n * @template V Value type of the enumeration item | 枚举项的值类型\n * @template FOL Field name of the label, default is `label` | 标签字段名，默认为 `label`\n * @template FOV Field name of the value, default is `value` | 值字段名，默认为 `value`\n */\nexport type ListItem<\n  V extends EnumValue = EnumValue,\n  FOV extends string = 'value',\n  FOL extends string = 'label',\n  R extends Record<string, unknown> = never,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n> = Record<FOV, V> & Record<FOL, string> & (IsNever<R> extends true ? {} : R);\n\n/** Enum value type, support number, string, symbol */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EnumValue = keyof any | bigint | boolean | Date | RegExp;\n\n/** Enum key collection */\nexport type EnumKey<T> = keyof T;\n\n/** Infer the value type from the initialization object of the enumeration item */\nexport type ValueTypeFromSingleInit<T, Key = string, Fallback = Key> = T extends EnumValue // literal类型\n  ? T\n  : T extends StandardEnumItemInit<infer V> // typeof {value, label}\n    ? V\n    : T extends ValueOnlyEnumItemInit<infer V> // typeof {value}\n      ? V\n      : T extends LabelOnlyEnumItemInit // typeof {label}\n        ? Key\n        : T extends MetaOnlyEnumItemInit // typeof {label}\n          ? Key\n          : T extends CompactEnumItemInit // typeof {}\n            ? Key\n            : T extends undefined // typeof undefined\n              ? Fallback\n              : never;\n\n/** Infer the value type from the initialization object of the enumeration collection */\nexport type ValueTypeFromEnumInit<T, K extends EnumKey<T> = EnumKey<T>> =\n  T extends NumberEnumInit<K> // format: { foo:1, bar:2 }\n    ? number\n    : T extends StringEnumInit<K> // format: { foo:'foo', bar:'bar' }\n      ? string\n      : T extends BooleanEnumInit<K> // format: { foo:true, bar:false }\n        ? string\n        : T extends StringNumberEnumInit<K> // format: { foo:'foo', bar:2 }\n          ? string | number\n          : T extends StandardEnumInit<K, infer V> // format: { foo:{ value:1, label:'foo'}, bar:{value:2, label:'bar'} }\n            ? V\n            : T extends ValueOnlyEnumInit<K, infer V> // format: { foo:{value:1}, bar:{value:2} }\n              ? V\n              : T extends LabelOnlyEnumInit<K> // format: { foo:{label:'foo'}, bar:{label:'bar'} }\n                ? K\n                : T extends MetaOnlyEnumInit<K> // format: { foo:{ meta1: \"\", meta2: \"\"}, bar:{ meta1: \"\", meta2: \"\"} }\n                  ? K\n                  : T extends CompactEnumInit<K> // format: { foo:{}, bar:{} }\n                    ? K\n                    : T extends OmitEnumInit<K> // format: {foo: undefined, bar: undefined}\n                      ? K\n                      : K; // Unknown format, use key as value\n\n/**\n * - **EN:** Find the key of the enumeration item by value\n * - **CN:** 通过值查找枚举项的key\n *\n * @template T Enum collection initialization data type | 枚举集合初始化数据的类型\n * @template V Enum value type | 枚举值的类型\n */\nexport type FindEnumKeyByValue<T, V extends EnumValue> = {\n  // ValueOnly: { foo:1, bar:2 }\n  [K in keyof T]: T[K] extends V\n    ? K\n    : // @ts-expect-error: because need to force check T[K]['value'], event value field does not exist\n      // Standard: { foo:{ value:1 }, bar:{ value:2 } }\n      T[K]['value'] extends V\n      ? K\n      : // LabelOnly: { foo:{ label: 'foo' }, bar:{ label: 'bar' } }\n        object extends T[K]\n        ? K extends V\n          ? K\n          : never\n        : // KeyOnly: { foo: undefined, bar: undefined }\n          undefined extends T[K]\n          ? K extends V\n            ? K\n            : never\n          : never;\n}[keyof T];\n\n/**\n * - **EN:** Find the label of the enumeration item by value\n * - **CN:** 通过值查找枚举项的label显示名称\n *\n * @template T Enum collection initialization data type | 枚举集合初始化数据的类型\n * @template V Enum value type | 枚举值的类型\n */\nexport type FindLabelByValue<T, V extends EnumValue, RAW = T[FindEnumKeyByValue<T, V>]> = RAW extends { label: unknown }\n  ? string\n  : FindEnumKeyByValue<T, V>;\n\n/**\n * - **EN:** Find the value of the enumeration item by key\n * - **CN:** 通过key查找枚举项的值\n *\n * @template T Enum collection initialization data type | 枚举集合初始化数据的类型\n * @template K Enum key type | 枚举key的类型\n */\nexport type FindValueByKey<T, K extends EnumKey<T>> = T[K] extends EnumValue\n  ? T[K]\n  : T[K] extends StandardEnumItemInit<infer V>\n    ? V\n    : T[K] extends ValueOnlyEnumItemInit<infer V>\n      ? V\n      : T[K] extends LabelOnlyEnumItemInit\n        ? K\n        : T[K] extends MetaOnlyEnumItemInit\n          ? K\n          : T[K] extends CompactEnumItemInit\n            ? K\n            : T[K] extends undefined\n              ? K\n              : never;\n\nexport type FindKeyByMeta<T, MK extends keyof T[keyof T], MV> = {\n  [K in keyof T]: T[K] extends Record<MK, MV> ? K : never;\n}[keyof T];\n\nexport type FindValueByMeta<T, MK extends keyof T[keyof T], MV> = {\n  [K in keyof T]: T[K] extends Record<MK, MV> ? T[K][MK] : never;\n}[keyof T];\n\nexport type PrimitiveOf<T> = T extends string\n  ? string\n  : T extends number\n    ? number\n    : T extends boolean\n      ? boolean\n      : T extends bigint\n        ? bigint\n        : T extends symbol\n          ? symbol\n          : T extends undefined\n            ? undefined\n            : T extends null\n              ? null\n              : never;\n\n/**\n * - **EN:** Convert an array of objects to a Map-like object, where the key is the `key` field of the\n *   object, and the value is the `value` field of the object\n * - **CN:** 将对象数组转换为类似Map的对象，其中key为对象的`key`字段，value为对象的`value`字段\n *\n * @template A Array type | 数组类型\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ArrayToMap<A extends Record<string, any>[] | readonly Record<string, any>[]> = {\n  [K in A[number]['key']]: Extract<A[number], { key?: K }>;\n};\n\nexport type ExactEqual<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;\n\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\n"]}