{"version":3,"file":"enum-items.js","sourceRoot":"../","sources":["src/enum-items.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EnumItemOptions } from './enum-item';\nimport { EnumItemClass } from './enum-item';\nimport type {\n  EnumInit,\n  EnumItemInit,\n  EnumItemLabel,\n  EnumKey,\n  EnumValue,\n  ExactEqual,\n  FindEnumKeyByValue,\n  FindKeyByMeta,\n  FindLabelByValue,\n  FindValueByKey,\n  FindValueByMeta,\n  ListItem,\n  PrimitiveOf,\n  StandardEnumItemInit,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { IS_ENUM_ITEMS, KEYS, VALUES } from './utils';\n\n/**\n * Enum items array, mostly are simple wrappers for EnumCollectionClass\n *\n * @template T Type of the initialization data of the enum collection\n *\n * @class EnumItemsArray\n *\n * @extends {EnumItemClass<T, K, V>[]}\n *\n * @implements {IEnumItems<T, K, V>}\n */\nexport class EnumItemsArray<\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n  >\n  extends Array<EnumItemClass<T[K], K, V, P>>\n  implements IEnumItems<T, K, V, P>\n{\n  private __raw__!: T;\n  /**\n   * - **EN:** A boolean value indicates that this is an enum items array.\n   * - **CN:** å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæšä¸¾é¡¹æ•°ç»„\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM_ITEMS](): true {\n    return true;\n  }\n  readonly [KEYS]!: K[];\n  readonly [VALUES]!: V[];\n  readonly labels!: string[];\n  readonly named!: {\n    [key in keyof T]: EnumItemClass<\n      // @ts-expect-error: because the first type parameter T is a union type, T[key] cannot satisfy each one of T.\n      T[key],\n      key,\n      ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>,\n      P\n    >;\n  };\n  readonly meta!: IEnumItems<T, K, V, P>['meta'];\n  private _runtimeError: (name: string) => string;\n\n  /**\n   * Instantiate an enum items array\n   *\n   * @memberof EnumItemsArray\n   *\n   * @param {T} raw Original initialization data object\n   * @param {EnumItemOptions<T[K], K, V, P> | undefined} options Enum item options\n   */\n  constructor(raw: T, options: EnumItemOptions<T[K], K, V, P> | undefined) {\n    super();\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '__raw__', {\n      value: raw,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n\n    // Generate keys array\n    // exclude number keys with a \"reverse mapping\" value, it means those \"reverse mapping\" keys of number enums\n    const keys = parseKeys<T, K, V>(raw);\n    const parsed = keys.map((key) => parseEnumItem<EnumItemInit<V>, K, V>(raw[key], key));\n    this[KEYS] = keys;\n    Object.freeze(keys);\n\n    const items: EnumItemClass<T[K], K, V, P>[] = [];\n    const meta = {} as { [K in Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>]: T[keyof T][K][] };\n    this.meta = meta as IEnumItems<T, K, V, P>['meta'];\n    const named = {} as Record<K, EnumItemClass<T[K], K, V, P>>;\n    this.named = named as IEnumItems<T, K, V, P>['named'];\n    keys.forEach((key, index) => {\n      const { value, label } = parsed[index];\n      const item = new EnumItemClass<T[K], K, V, P>(key, value, label, raw[key], options);\n      items.push(item);\n      this.push(item);\n      named[key] = item;\n\n      // Collect custom meta fields\n      const itemRaw = raw[key];\n      if (itemRaw && typeof itemRaw === 'object') {\n        Object.keys(itemRaw).forEach((k) => {\n          const metaKey = k as Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>;\n          if (metaKey !== 'key' && metaKey !== 'value' && metaKey !== 'label') {\n            if (meta[metaKey] == null) {\n              meta[metaKey] = [];\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const metaValue = (itemRaw as any)[metaKey];\n            if (metaValue != null) {\n              meta[metaKey].push(metaValue);\n            }\n          }\n        });\n      }\n    });\n    // Freeze meta arrays\n    Object.keys(meta).forEach((k) => {\n      Object.freeze(meta[k as keyof typeof meta]);\n    });\n\n    // Generate values array\n    const values = parsed.map((item) => item.value);\n    this[VALUES] = values;\n    Object.freeze(values);\n\n    // Generate labels array\n    Object.defineProperty(this, 'labels', {\n      get: function (this: EnumItemsArray<T, K, V, P>) {\n        // Cannot save to static array because labels may be localized contents\n        // Should not use `items` in the closure because the getter function cannot be fully serialized\n        return Array.from(this).map((item) => item.label);\n      },\n      enumerable: true,\n      configurable: false,\n    });\n\n    this._runtimeError = undefined!;\n    Object.defineProperty(this, '_runtimeError', {\n      value: function (this: EnumItemsArray<T, K, V, P>, name: string) {\n        return `The ${name} property of the enumeration is only allowed to be used to declare the ts type, and cannot be accessed at runtime! Please use the typeof operator in the ts type, for example: typeof Week.${name}`;\n      },\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n  }\n\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V> {\n    // intentionally use == to support both number and string format value\n    return this.some(\n      // eslint-disable-next-line eqeqeq\n      (i) => (instance as unknown as V) == i.value || (instance as unknown as K) === i.key\n    );\n  }\n\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>] extends { label: unknown }\n            ? T[NonNullable<KV>]['label'] extends undefined\n              ? NonNullable<KV>\n              : string\n            : NonNullable<KV>\n          : NonNullable<KV> extends V\n            ? FindLabelByValue<T, NonNullable<KV>>\n            : PrimitiveOf<K> extends KV\n              ? string | undefined\n              : PrimitiveOf<V> extends KV\n                ? string | undefined\n                : undefined) {\n    // Find by value, then try key\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.find((i) => i.value === keyOrValue) ?? this.find((i) => i.key === keyOrValue))?.label as any;\n  }\n\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(\n    value?: IV\n  ):\n    | (undefined extends IV ? undefined : never)\n    | (IV extends undefined\n        ? undefined\n        : NonNullable<IV> extends V\n          ? FindEnumKeyByValue<T, NonNullable<IV>>\n          : PrimitiveOf<V> extends NonNullable<IV>\n            ? K | undefined\n            : undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this.find((i) => i.value === value)?.key as any;\n  }\n\n  raw(): T;\n  raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(\n    keyOrValue: IK\n  ): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;\n  raw<IK extends EnumValue>(keyOrValue?: IK | unknown): T | T[K] | T[FindEnumKeyByValue<T, IK>] | undefined {\n    if (keyOrValue == null) {\n      // Return the original initialization object\n      return this.__raw__;\n    } else {\n      // Find by key\n      if (Object.keys(this.__raw__).some((k) => k === keyOrValue)) {\n        return this.__raw__[keyOrValue as K];\n      }\n      // Find by value\n      const itemByValue = this.find((i) => i.value === keyOrValue);\n      if (itemByValue) {\n        return itemByValue.raw;\n      }\n      return undefined;\n    }\n  }\n\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V> {\n    return this.some((i) => i.value === (keyOrValue as unknown as V) || i.key === (keyOrValue as unknown as K));\n  }\n\n  findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, FV>(\n    field: FK,\n    value: FV\n  ): FK extends 'key'\n    ? FV extends K\n      ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of K\n        EnumItemClass<T[FV], FV, FindValueByKey<T, FV>>\n      : EnumItemClass<T[K], K, V, P> | undefined\n    : FK extends 'value'\n      ? FV extends V\n        ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of V\n          EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV>\n        : EnumItemClass<T[K], K, V, P> | undefined\n      : FK extends 'label'\n        ? EnumItemClass<T[K], K, V, P> | undefined\n        : // @ts-expect-error: because the type infer is not clever enough, FK here should be one of keyof Raw\n          FV extends T[keyof T][FK]\n          ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of T[keyof T][FK]\n            EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>>\n          : EnumItemClass<T[K], K, V, P> | undefined {\n    return this.find((item) => {\n      if (field === 'key' || field === 'value') {\n        return item[field as keyof typeof item] === value;\n      } else if (field === 'label') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item.raw as any)?.label === value || item.label === value;\n      } else {\n        // For other fields, use the raw object to find\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item.raw as any)?.[field] === value;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }) as any;\n  }\n\n  toList(): ListItem<V, 'value', 'label'>[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n    R\n  >[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config?: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ):\n    | ListItem<V, 'value', 'label'>[]\n    | ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n        R\n      >[] {\n    const { valueField = 'value' as FOV, labelField = 'label' as FOL, extra } = config ?? {};\n    return Array.from(this).map((item) => {\n      const valueFieldName = typeof valueField === 'function' ? valueField(item) : (valueField as string);\n      const labelFieldName = typeof labelField === 'function' ? labelField(item) : (labelField as string);\n      const extraData = extra ? (extra(item) as R) : ({} as R);\n      const listItem = {\n        [valueFieldName]: item.value,\n        [labelFieldName]: item.label,\n        ...extraData,\n      } as ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n        R\n      >;\n      return listItem;\n    });\n  }\n\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(config?: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P> {\n    if (!config) {\n      return this.reduce(\n        (prev, cur) => {\n          prev[cur.value] = cur.label;\n          return prev;\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any\n      ) as unknown as MapResult<T, KS, VS, K, V, P>;\n    }\n    const { keySelector = 'value', valueSelector = 'label' } = config;\n    return this.reduce(\n      (prev, cur) => {\n        let key: string | symbol;\n        if (typeof keySelector === 'function') {\n          key = keySelector(cur);\n        } else {\n          key = cur[keySelector as keyof EnumItemClass<T[K], K, V, P>] as string | symbol;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let value: any;\n        if (typeof valueSelector === 'function') {\n          value = valueSelector(cur);\n        } else {\n          value = cur[valueSelector as keyof EnumItemClass<T[K], K, V, P>] as unknown;\n        }\n        prev[key as keyof MapResult<T, KS, VS, K, V, P>] = value;\n        return prev;\n      },\n      {} as MapResult<T, KS, VS, K, V, P>\n    ) as unknown as MapResult<T, KS, VS, K, V, P>;\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get valueType(): V {\n    throw new Error(this._runtimeError('valueType'));\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get keyType(): K {\n    throw new Error(this._runtimeError('keyType'));\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get rawType(): T[K] {\n    throw new Error(this._runtimeError('rawType'));\n  }\n}\n\n/**\n * - **EN:** Enum item collection interface, excluding members inherited from the array\n * - **CN:** æšä¸¾é¡¹é›†åˆæ¥å£ï¼Œä¸åŒ…å«ä»æ•°ç»„é›†æˆçš„æˆå‘˜\n *\n * @template T The type of enum initialization | æšä¸¾åˆå§‹åŒ–çš„ç±»å‹\n * @template K The type of enum keys | æšä¸¾é”®çš„ç±»å‹\n * @template V The type of enum values | æšä¸¾å€¼çš„ç±»å‹\n *\n * @interface IEnumItems\n */\nexport interface IEnumItems<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> extends InheritableEnumItems<T, K, V, P> {\n  /**\n   * - **EN:** A boolean value indicates that this is an enum items array.\n   * - **CN:** å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæšä¸¾é¡¹æ•°ç»„\n   */\n  [IS_ENUM_ITEMS]: true;\n  /**\n   * - **EN:** Get all keys of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨keysåˆ—è¡¨\n   *\n   * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•\n   */\n  readonly [KEYS]: K[];\n  /**\n   * - **EN:** Get all values of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨valuesåˆ—è¡¨\n   *\n   * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•\n   */\n  readonly [VALUES]: V[];\n  /**\n   * - **EN:** Get all labels of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨labelsåˆ—è¡¨\n   *\n   * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•\n   */\n  readonly labels: string[];\n\n  /**\n   * - **EN:** A mapping of enum keys to their corresponding enum item classes. This is useful for\n   *   quick access to specific enum items.\n   * - **CN:** æšä¸¾é”®åˆ°å…¶å¯¹åº”çš„æšä¸¾é¡¹ç±»çš„æ˜ å°„ï¼Œå¯¹äºå¿«é€Ÿè®¿é—®æšä¸¾é¡¹éå¸¸æœ‰ç”¨\n   */\n  named: {\n    [key in keyof T]: EnumItemClass<\n      // @ts-expect-error: because the first type parameter T is a union type, T[key] cannot satisfy each one of T.\n      T[key],\n      key,\n      ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>,\n      P\n    >;\n  };\n\n  /**\n   * - **EN:** Get all custom meta fields of the enumeration items as an object, where the keys are\n   *   the field names, and values are the raw values of each field\n   * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨è‡ªå®šä¹‰å…ƒå­—æ®µï¼Œè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­keyä¸ºå­—æ®µåï¼Œvalueä¸ºæ¯ä¸ªå­—æ®µçš„åŸå§‹å€¼æ•°ç»„\n   */\n  readonly meta: T extends object\n    ? { [K in Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>]: T[keyof T][K][] }\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n      {};\n}\n\n// typeof IS_ENUM_ITEMS | typeof ITEMS | typeof KEYS | typeof VALUES | 'labels' | 'meta' | 'named'\nexport interface InheritableEnumItems<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** A method that determines if a constructor object recognizes an object as one of the\n   *   constructorâ€™s instances. Called by the semantics of the `instanceof` operator.\n   * - **CN:** ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºç¡®å®šæ„é€ å‡½æ•°å¯¹è±¡æ˜¯å¦å°†å¯¹è±¡è¯†åˆ«ä¸ºæ„é€ å‡½æ•°çš„å®ä¾‹ä¹‹ä¸€ã€‚ç”± `instanceof` è¿ç®—ç¬¦çš„è¯­ä¹‰è°ƒç”¨ã€‚\n   */\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V>;\n  /**\n   * - **EN:** The enum collection name, supports localization.\n   *\n   * > Note that it usually returns a string, but if a custom `localize` function is set, the return\n   * > value may vary depending on the implementation of the method.\n   *\n   * - **CN:** æšä¸¾é›†åˆæ˜¾ç¤ºåç§°ï¼Œæ”¯æŒæœ¬åœ°åŒ–ã€‚\n   *\n   * > æ³¨æ„ï¼Œé€šå¸¸æƒ…å†µä¸‹è¿”å›çš„æ˜¯å­—ç¬¦ä¸²ï¼Œä½†å¦‚æœè®¾ç½®äº†è‡ªå®šä¹‰çš„ `localize` å‡½æ•°ï¼Œåˆ™è¿”å›å€¼å¯èƒ½æœ‰æ‰€ä¸åŒï¼Œå–å†³äºæ–¹æ³•çš„å®ç°\n   *\n   * @returns {string | undefined} The localized name of the enum collection, or undefined if not\n   *   set | æšä¸¾é›†åˆçš„æœ¬åœ°åŒ–åç§°ï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä¸º undefined\n   */\n  readonly name?: string;\n  /**\n   * - **EN:** Get the label (also known as display name) of the enumeration item, supports getting by\n   *   value or key\n   * - **CN:** è·å–æšä¸¾é¡¹çš„æ ‡ç­¾ï¼ˆäº¦ç§°æ˜¾ç¤ºåç§°ï¼‰ï¼Œæ”¯æŒé€šè¿‡æšä¸¾é¡¹çš„ value æˆ– key è·å–\n   *\n   * @param keyOrValue - The value or key of the enumeration item | æšä¸¾é¡¹çš„ value æˆ– key\n   *\n   * @returns The label of the enumeration item or the key if the label is not defined | æšä¸¾é¡¹çš„æ ‡ç­¾æˆ–\n   *   keyï¼ˆå¦‚æœæ ‡ç­¾æœªå®šä¹‰ï¼‰\n   */\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>] extends { label: unknown }\n            ? T[NonNullable<KV>]['label'] extends undefined\n              ? NonNullable<KV>\n              : string\n            : NonNullable<KV>\n          : NonNullable<KV> extends V\n            ? FindLabelByValue<T, NonNullable<KV>>\n            : PrimitiveOf<K> extends KV\n              ? string | undefined\n              : PrimitiveOf<V> extends KV\n                ? string | undefined\n                : undefined);\n\n  /**\n   * - **EN:** Get the key of the enumeration item by its value\n   * - **CN:** æ ¹æ®æšä¸¾é¡¹çš„ value è·å–å…¶ key\n   *\n   * @param value The value of the enumeration item | æšä¸¾é¡¹çš„ value\n   *\n   * @returns The key of the enumeration item, or undefined if not found | æšä¸¾é¡¹çš„ keyï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›\n   *   undefined\n   */\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(\n    value: IV\n  ):\n    | (undefined extends IV ? undefined : never)\n    | (IV extends undefined\n        ? undefined\n        : NonNullable<IV> extends V\n          ? FindEnumKeyByValue<T, NonNullable<IV>>\n          : PrimitiveOf<V> extends NonNullable<IV>\n            ? K | undefined\n            : undefined);\n\n  /**\n   * - **EN:** Get the enumeration item by key or value\n   * - **CN:** è·å–æšä¸¾é›†åˆçš„åˆå§‹åŒ–å¯¹è±¡\n   *\n   * @returns {T} Enum collection initialization object | åˆå§‹åŒ–å¯¹è±¡é›†åˆ\n   */\n  raw(): T;\n  /**\n   * - **EN:** Get the original initialization object of a certain enumeration item. If custom fields\n   *   are added to the enumeration item, you can use this method to get them.\n   * - **CN:** è·å–æŸä¸ªæšä¸¾é¡¹çš„åŸå§‹åˆå§‹åŒ–å¯¹è±¡ã€‚å¦‚æœåœ¨æšä¸¾é¡¹ä¸Šå¢åŠ äº†è‡ªå®šä¹‰å­—æ®µçš„è¯ï¼Œå¯ä»¥ç”¨è¿™ç§æ–¹å¼è·å–åˆ°ã€‚\n   *\n   * @param keyOrValue Enum key or value | æšä¸¾keyæˆ–value\n   *\n   * @returns The original initialization object of the enumeration item, or undefined if not found\n   *   | æšä¸¾é¡¹çš„åŸå§‹åˆå§‹åŒ–å¯¹è±¡ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› undefined\n   */\n  raw<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>]\n          : NonNullable<KV> extends V\n            ? T[FindEnumKeyByValue<T, NonNullable<KV>>]\n            : PrimitiveOf<K> extends KV\n              ? T[K] | undefined\n              : PrimitiveOf<V> extends KV\n                ? T[K] | undefined\n                : undefined);\n  /**\n   * - **EN:** Get the value corresponding to a certain enumeration item\n   * - **CN:** åˆ¤æ–­æŸä¸ªæšä¸¾é¡¹æ˜¯å¦å­˜åœ¨\n   *\n   * @param keyOrValue Enum item key or value | æšä¸¾é¡¹çš„keyæˆ–value\n   *\n   * @returns {boolean} Whether the enumeration item exists | æšä¸¾é¡¹æ˜¯å¦å­˜åœ¨\n   */\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V>;\n\n  /**\n   * **EN:** Find an enumeration item by key or value, or by custom meta fields\n   *\n   * **CN:** é€šè¿‡keyæˆ–valueæŸ¥æ‰¾æšä¸¾é¡¹ï¼Œæˆ–é€šè¿‡è‡ªå®šä¹‰å…ƒå­—æ®µæŸ¥æ‰¾\n   *\n   * @param field The field to search by | è¦æŸ¥æ‰¾çš„å­—æ®µ\n   * @param value The value to search | è¦æŸ¥æ‰¾çš„å€¼\n   *\n   * @returns The found enumeration item or `undefined` if not found | æ‰¾åˆ°çš„æšä¸¾é¡¹ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› `undefined`\n   */\n  findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, const FV>(\n    field: FK,\n    value: FV\n  ): FK extends 'key'\n    ? FV extends K\n      ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of K\n        EnumItemClass<T[FV], FV, FindValueByKey<T, FV>>\n      : EnumItemClass<T[K], K, V, P> | undefined\n    : FK extends 'value'\n      ? FV extends V\n        ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of V\n          EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV>\n        : EnumItemClass<T[K], K, V, P> | undefined\n      : FK extends 'label'\n        ? EnumItemClass<T[K], K, V, P> | undefined\n        : // @ts-expect-error: because the type infer is not clever enough, FK here should be one of keyof Raw\n          FV extends T[keyof T][FK]\n          ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of T[keyof T][FK]\n            EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>>\n          : EnumItemClass<T[K], K, V, P> | undefined;\n\n  /**\n   * - **EN:** Generate an object array containing all enumeration items\n   * - **CN:** ç”Ÿæˆä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹\n   *\n   * @example\n   *   [\n   *     { value: 0, label: 'Sunday' },\n   *     { value: 1, label: 'Monday' },\n   *   ];\n   *\n   * @returns An object array of all enumeration items | æ‰€æœ‰æšä¸¾é¡¹çš„å¯¹è±¡æ•°ç»„\n   */\n  toList(): ListItem<V, 'value', 'label'>[];\n  /**\n   * - **EN:** Generate an object array containing all enumeration items, with customizable value and\n   *   label field names\n   * - **CN:** ç”Ÿæˆä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œå¯è‡ªå®šä¹‰å€¼å’Œæ ‡ç­¾å­—æ®µå\n   *\n   * @example\n   *   Week.toList({\n   *     valueField: 'id',\n   *     labelField: 'name',\n   *   });\n   *\n   *   [\n   *     { id: 0, name: 'Sunday' },\n   *     { id: 1, name: 'Monday' },\n   *   ];\n   *\n   * @param config Custom options, supports customizing value and label field names |\n   *   è‡ªå®šä¹‰é€‰é¡¹ï¼Œæ”¯æŒè‡ªå®šä¹‰å€¼å’Œæ ‡ç­¾å­—æ®µå\n   *\n   * @returns An object array of all enumeration items in the specified value and label fields |\n   *   æ‰€æœ‰æšä¸¾é¡¹çš„å¯¹è±¡æ•°ç»„ï¼ŒæŒ‰ç…§æŒ‡å®šçš„å€¼å’Œæ ‡ç­¾å­—æ®µæ ¼å¼\n   */\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n    R\n  >[];\n\n  /**\n   * - **EN:** Generate a mapping object of all enum items, where the keys are the values of the enum\n   *   and the values are the labels of the enum\n   * - **CN:** ç”Ÿæˆä¸€ä¸ªæ˜ å°„å¯¹è±¡ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œkeyä¸ºæšä¸¾å€¼ï¼Œvalueä¸ºæšä¸¾æ ‡ç­¾\n   *\n   * @example\n   *   {\n   *     \"0\": \"Sunday\",\n   *     \"1\": \"Monday\"\n   *   }\n   *\n   * @returns A mapping object of all enum items | æ‰€æœ‰æšä¸¾é¡¹çš„æ˜ å°„å¯¹è±¡\n   */\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  /**\n   * - **EN:** Generate a mapping object of all enum items, with customizable key and value fields\n   * - **CN:** ç”Ÿæˆä¸€ä¸ªæ˜ å°„å¯¹è±¡ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œå¯è‡ªå®šä¹‰é”®å’Œå€¼å­—æ®µ\n   *\n   * @example\n   *   Week.toMap({ key: 'value', value: 'label' });\n   *\n   *   ({ '0': 'Sunday', '1': 'Monday' });\n   *\n   *   /// Allow custom function, and meta fields can be used\n   *   Week.toMap({\n   *     key: 'key',\n   *     value: (item) => ({ id: item.value, name: item.label, foo: item.raw.foo }),\n   *   });\n   *\n   *   ({\n   *     Sunday: { id: 0, name: 'Sunday', foo: 'bar' },\n   *     Monday: { id: 1, name: 'Monday', foo: 'b' },\n   *   });\n   *\n   * @param config Custom options, supports customizing key and value fields | è‡ªå®šä¹‰é€‰é¡¹ï¼Œæ”¯æŒè‡ªå®šä¹‰é”®å’Œå€¼å­—æ®µ\n   *\n   * @returns A mapping object of all enum items in the specified key and value fields |\n   *   æ‰€æœ‰æšä¸¾é¡¹çš„æ˜ å°„å¯¹è±¡ï¼ŒæŒ‰ç…§æŒ‡å®šçš„é”®å’Œå€¼å­—æ®µæ ¼å¼\n   */\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    FOK extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    FOV extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(\n    config: ToMapConfig<T, FOK, FOV, K, V, P>\n  ): MapResult<T, FOK, FOV, K, V, P>;\n\n  /**\n   * - **EN:** The data type of all enumeration values\n   *\n   * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** æ‰€æœ‰æšä¸¾å€¼çš„æ•°æ®ç±»å‹\n   *\n   * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨\n   *\n   * @example\n   *   // Declare the type of the variable | å£°æ˜å˜é‡çš„ç±»å‹\n   *   const week: typeof Week.valueType = Week.Monday; // 0\n   *\n   *   // Declare type field | å£°æ˜ç±»å‹å­—æ®µ\n   *   type Props = {\n   *     week: typeof Week.valueType; // 0 | 1\n   *   };\n   */\n  valueType: V;\n\n  /**\n   * - **EN:** The data type of all enumeration keys\n   *\n   * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** æ‰€æœ‰æšä¸¾keyçš„æ•°æ®ç±»å‹\n   *\n   * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨\n   *\n   * @example\n   *   // Declare the type of the variable | å£°æ˜å˜é‡çš„ç±»å‹\n   *   const weekName: typeof Week.keyType = 'Sunday'; // \"Sunday\" | \"Monday\"\n   *\n   *   // Declare type field | å£°æ˜ç±»å‹å­—æ®µ\n   *   type Props = {\n   *     weekName: typeof Week.keyType; // \"Sunday\" | \"Monday\"\n   *   };\n   */\n  keyType: K;\n\n  /**\n   * - **EN:** The type of the original initialization object of the enumeration item. If custom\n   *   fields are added to the enumeration item, you can use this method to get them.\n   *\n   * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** æšä¸¾é¡¹åŸå§‹åˆå§‹åŒ–å¯¹è±¡çš„ç±»å‹ï¼Œå¦‚æœåœ¨æšä¸¾é¡¹ä¸Šå¢åŠ äº†è‡ªå®šä¹‰å­—æ®µçš„è¯ï¼Œå¯ä»¥ç”¨è¿™ç§æ–¹å¼è·å–åˆ°ã€‚\n   *\n   * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨\n   */\n  rawType: T[K];\n}\n\n/** More options for the options method */\nexport interface ToListConfig<\n  T extends EnumInit<K, V>,\n  FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  R extends Record<string, unknown> = never,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** The name of the value field in the output object, or a function to get the field name,\n   *   default is `value`\n   * - **CN:** è¾“å‡ºå¯¹è±¡çš„valueå­—æ®µåï¼Œæˆ–è€…è·å–å­—æ®µåçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `value`\n   */\n  valueField?: FOV;\n  /**\n   * - **EN:** The name of the label field in the output object, or a function to get the field name,\n   *   default is `label`\n   * - **CN:** è¾“å‡ºå¯¹è±¡çš„labelå­—æ®µåï¼Œæˆ–è€…è·å–å­—æ®µåçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `label`\n   */\n  labelField?: FOL;\n  /**\n   * - **EN:** A function to add extra fields to each item in the output object\n   * - **CN:** ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºä¸ºè¾“å‡ºå¯¹è±¡ä¸­çš„æ¯ä¸ªé¡¹æ·»åŠ é¢å¤–çš„å­—æ®µ\n   */\n  extra?: (item: EnumItemClass<T[K], K, V, P>) => R;\n}\n\nexport interface ToMapConfig<\n  T extends EnumInit<K, V>,\n  KS extends\n    | EnumItemFields\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** A field of `EnumItem` as the key of the output object, or a function to get the key of\n   *   items, default is `key`\n   * - **CN:** ä½œä¸ºè¾“å‡ºå¯¹è±¡keyçš„`EnumItem`å­—æ®µåï¼Œæˆ–è€…è·å–è¾“å‡ºå¯¹è±¡keyçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `key`\n   */\n  keySelector?: KS;\n  /**\n   * - **EN:** A field of `EnumItem` as the value of the output object, or a function to get the value\n   *   of items, default is `value`\n   * - **CN:** ä½œä¸ºè¾“å‡ºå¯¹è±¡valueçš„`EnumItem`å­—æ®µåï¼Œæˆ–è€…è·å–è¾“å‡ºå¯¹è±¡valueçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `value`\n   */\n  valueSelector?: VS;\n}\n\nexport type MapResult<\n  T extends EnumInit<K, V>,\n  KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol),\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> = {\n  [key in ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      EnumItemClass<T[K], K, V, P>['value'] & keyof any\n    : KS extends EnumItemFields\n      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        EnumItemClass<T[K], K, V, P>[KS] & keyof any\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        KS extends (item: any) => infer R\n        ? R\n        : never]: ExactEqual<VS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => unknown)> extends true\n    ? ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true\n      ? FindLabelByValue<T, key>\n      : EnumItemClass<T[K], K, V, P>['label']\n    : VS extends EnumItemFields\n      ? EnumItemClass<T[K], K, V, P>[VS]\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        VS extends (item?: any) => infer R\n        ? R\n        : never;\n};\n\nexport type EnumItemFields = Exclude<\n  {\n    [key in keyof EnumItemClass<StandardEnumItemInit<string>>]: EnumItemClass<\n      StandardEnumItemInit<string>\n    >[key] extends (...args: any[]) => unknown\n      ? never\n      : key;\n  }[keyof EnumItemClass<StandardEnumItemInit<string>>] &\n    string,\n  'raw'\n>;\n\nexport function parseKeys<\n  const T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n>(raw: EnumInit<K, V>) {\n  return Object.keys(raw).filter((k) => !(/^-?\\d+$/.test(k) && k === `${raw[raw[k as K] as K] ?? ''}`)) as K[];\n}\n\nfunction parseEnumItem<\n  T extends EnumItemInit<V>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  K extends EnumKey<any>,\n  V extends EnumValue,\n>(init: T, key: K): StandardEnumItemInit<V> {\n  let value: V;\n  let label: EnumItemLabel;\n  if (init != null) {\n    if (typeof init === 'number' || typeof init === 'string' || typeof init === 'symbol') {\n      value = init as V;\n      label = key as EnumItemLabel;\n    } else if (typeof init === 'object') {\n      // Initialize using object\n      if (Object.prototype.toString.call(init) === '[object Object]') {\n        if ('value' in init && Object.keys(init).some((k) => k === 'value')) {\n          // type of {value, label}\n          value = (init.value ?? key) as V;\n          if ('label' in init && Object.keys(init).some((k) => k === 'label')) {\n            label = init.label!;\n          } else {\n            label = key as EnumItemLabel;\n          }\n        } else if ('label' in init && Object.keys(init).some((k) => k === 'label')) {\n          // typeof {label}\n          value = key as unknown as V;\n          label = init.label ?? (key as EnumItemLabel);\n        } else {\n          // {} empty object\n          value = key as unknown as V;\n          label = key as EnumItemLabel;\n        }\n      } else {\n        // Probably Date, RegExp and other primitive types\n        value = init as V;\n        label = key as EnumItemLabel;\n      }\n    } else {\n      throw new Error(`Invalid enum item: ${JSON.stringify(init)}`);\n    }\n  } else {\n    value = key as unknown as V;\n    label = key as EnumItemLabel;\n  }\n  return { value, label };\n}\n"]}