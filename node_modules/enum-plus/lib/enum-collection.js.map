{"version":3,"file":"enum-collection.js","sourceRoot":"../","sources":["src/enum-collection.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EnumExtension } from 'enum-plus/extension';\nimport type { EnumInitOptions } from './enum';\nimport type { EnumItemClass, EnumItemOptions } from './enum-item';\nimport type { EnumItemFields, InheritableEnumItems, MapResult, ToListConfig, ToMapConfig } from './enum-items';\nimport { EnumItemsArray } from './enum-items';\nimport { localizer } from './global-config';\nimport type {\n  EnumInit,\n  EnumKey,\n  EnumValue,\n  FindEnumKeyByValue,\n  ListItem,\n  PrimitiveOf,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { ENUM_OPTIONS, IS_ENUM, ITEMS, KEYS, LABELS, META, NAMED, VALUES } from './utils';\n\n/**\n * - **EN:** Enum collection extension base class, used to extend the Enums\n * - **CN:** 枚举集合扩展基类，用于扩展枚举\n */\n// @ts-expect-error: because don't know which methods are added\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class EnumExtensionClass<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n> implements EnumExtension<T, K, V> {}\n\n/**\n * - **EN:** Enum collection\n * - **CN:** 枚举项集合\n */\nexport class EnumCollectionClass<\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n  >\n  extends EnumExtensionClass<T, K, V>\n  implements InheritableEnumItems<T, K, V, P>\n{\n  private readonly __options__: EnumInitOptions<T, K, V, P> | undefined;\n  // used for e2e serialization\n  private readonly __items__!: EnumItemsArray<T, K, V, P>;\n\n  constructor(init: T = {} as T, options?: EnumInitOptions<T, K, V, P>) {\n    super();\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '__options__', {\n      value: options,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    const keys = Object.keys(init) as K[];\n    // Generate enum items array\n    const items = new EnumItemsArray<T, K, V, P>(init, options);\n    Object.freeze(items);\n    // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken\n    this[keys.includes('items') ? ITEMS : 'items'] = items;\n    Object.defineProperty(this, '__items__', {\n      value: items,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // @ts-expect-error: because use KEYS to avoid naming conflicts in case of 'keys' field name is taken\n    this[keys.includes('keys') ? KEYS : 'keys'] = items[KEYS];\n\n    // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken\n    this[keys.includes('values') ? VALUES : 'values'] = items[VALUES];\n\n    // @ts-expect-error: because use NAMED to avoid naming conflicts in case of 'named' field name is taken\n    this[keys.includes('named') ? NAMED : 'named'] = items.named;\n\n    // @ts-expect-error: because use META to avoid naming conflicts in case of 'meta' field name is taken\n    this[keys.includes('meta') ? META : 'meta'] = items.meta;\n\n    // Add keys to the instance, allows picking enum values by keys\n    items.forEach((item) => {\n      // @ts-expect-error: because of dynamic property\n      this[item.key] = item.value;\n    });\n\n    // @ts-expect-error: because use LABELS to avoid naming conflicts in case of 'labels' field name is taken\n    Object.defineProperty(this, keys.includes('labels') ? LABELS : 'labels', {\n      enumerable: true,\n      configurable: false,\n      get: function (this: EnumCollectionClass<T, K, V, P>) {\n        return this.__items__.labels;\n      },\n    });\n\n    Object.freeze(this);\n  }\n  /**\n   * - **EN:** A boolean value indicates that this is an enum collection instance.\n   * - **CN:** 布尔值，表示这是一个枚举集合实例\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM](): true {\n    return true;\n  }\n  /**\n   * - **EN:** Get the options to initialize the enum.\n   * - **CN:** 获取初始化枚举时的选项\n   */\n  get [ENUM_OPTIONS](): EnumItemOptions<T[K], K, V, P> | undefined {\n    return this.__options__;\n  }\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V> {\n    return instance instanceof this.__items__;\n  }\n  /**\n   * The enum collection name, supports localization. Note that it usually returns a string, but if\n   * a custom `localize` function is set, the return value may vary depending on the implementation\n   * of the method.\n   *\n   * - **CN:** 枚举集合显示名称，支持本地化。注意，通常情况下返回的是字符串，但如果设置了自定义的 `localize` 函数，则返回值可能有所不同，取决于方法的实现\n   *\n   * @returns {string | undefined} The localized name of the enum collection, or undefined if not\n   *   set.\n   */\n  get name(): string | undefined {\n    if (typeof this.__options__?.name === 'function') {\n      return this.__options__.name(undefined!);\n    }\n    const localize = this.__options__?.localize ?? localizer.localize;\n    if (typeof localize === 'function') {\n      return localize(this.__options__?.name);\n    }\n    return this.__options__?.name;\n  }\n\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV) {\n    return this.__items__.label(keyOrValue);\n  }\n\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(value?: IV) {\n    return this.__items__.key(value);\n  }\n\n  raw(): T;\n  raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(\n    keyOrValue: IK\n  ): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;\n  raw<IK extends EnumValue>(value?: IK | unknown): T | T[K] | T[FindEnumKeyByValue<T, IK>] | undefined {\n    if (value != null) {\n      return this.__items__.raw(value as keyof T | EnumValue) as T[K];\n    } else {\n      return this.__items__.raw();\n    }\n  }\n\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V> {\n    return this.__items__.has(keyOrValue);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  findBy(...rest: Parameters<EnumItemsArray<T, K, V, P>['findBy']>): any {\n    return this.__items__.findBy(...rest);\n  }\n\n  toList(): ListItem<V, 'value', 'label'>[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n  >[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config?: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ):\n    | ListItem<V, 'value', 'label'>[]\n    | ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n      >[] {\n    return this.__items__.toList(config as ToListConfig<T, FOV, FOL, K, V, never, P>);\n  }\n\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config?: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P> {\n    return this.__items__.toMap(config as ToMapConfig<T, KS, VS, K, V, P>);\n  }\n\n  get valueType() {\n    return this.__items__.valueType;\n  }\n  get keyType() {\n    return this.__items__.keyType;\n  }\n  get rawType() {\n    return this.__items__.rawType;\n  }\n}\n"]}