"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumCollectionClass = exports.EnumExtensionClass = void 0;
const enum_items_1 = require("./enum-items");
const global_config_1 = require("./global-config");
const utils_1 = require("./utils");
/**
 * - **EN:** Enum collection extension base class, used to extend the Enums
 * - **CN:** 枚举集合扩展基类，用于扩展枚举
 */
// @ts-expect-error: because don't know which methods are added
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class EnumExtensionClass {
}
exports.EnumExtensionClass = EnumExtensionClass;
/**
 * - **EN:** Enum collection
 * - **CN:** 枚举项集合
 */
class EnumCollectionClass extends EnumExtensionClass {
    constructor(init = {}, options) {
        super();
        // Do not use class field here, because don't want print this field in Node.js
        Object.defineProperty(this, '__options__', {
            value: options,
            writable: false,
            enumerable: false,
            configurable: false,
        });
        const keys = Object.keys(init);
        // Generate enum items array
        const items = new enum_items_1.EnumItemsArray(init, options);
        Object.freeze(items);
        // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken
        this[keys.includes('items') ? utils_1.ITEMS : 'items'] = items;
        Object.defineProperty(this, '__items__', {
            value: items,
            writable: false,
            enumerable: false,
            configurable: false,
        });
        // @ts-expect-error: because use KEYS to avoid naming conflicts in case of 'keys' field name is taken
        this[keys.includes('keys') ? utils_1.KEYS : 'keys'] = items[utils_1.KEYS];
        // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken
        this[keys.includes('values') ? utils_1.VALUES : 'values'] = items[utils_1.VALUES];
        // @ts-expect-error: because use NAMED to avoid naming conflicts in case of 'named' field name is taken
        this[keys.includes('named') ? utils_1.NAMED : 'named'] = items.named;
        // @ts-expect-error: because use META to avoid naming conflicts in case of 'meta' field name is taken
        this[keys.includes('meta') ? utils_1.META : 'meta'] = items.meta;
        // Add keys to the instance, allows picking enum values by keys
        items.forEach((item) => {
            // @ts-expect-error: because of dynamic property
            this[item.key] = item.value;
        });
        // @ts-expect-error: because use LABELS to avoid naming conflicts in case of 'labels' field name is taken
        Object.defineProperty(this, keys.includes('labels') ? utils_1.LABELS : 'labels', {
            enumerable: true,
            configurable: false,
            get: function () {
                return this.__items__.labels;
            },
        });
        Object.freeze(this);
    }
    /**
     * - **EN:** A boolean value indicates that this is an enum collection instance.
     * - **CN:** 布尔值，表示这是一个枚举集合实例
     */
    // Do not use readonly field here, because don't want print this field in Node.js
    // eslint-disable-next-line @typescript-eslint/class-literal-property-style
    get [utils_1.IS_ENUM]() {
        return true;
    }
    /**
     * - **EN:** Get the options to initialize the enum.
     * - **CN:** 获取初始化枚举时的选项
     */
    get [utils_1.ENUM_OPTIONS]() {
        return this.__options__;
    }
    [Symbol.hasInstance](instance) {
        return instance instanceof this.__items__;
    }
    /**
     * The enum collection name, supports localization. Note that it usually returns a string, but if
     * a custom `localize` function is set, the return value may vary depending on the implementation
     * of the method.
     *
     * - **CN:** 枚举集合显示名称，支持本地化。注意，通常情况下返回的是字符串，但如果设置了自定义的 `localize` 函数，则返回值可能有所不同，取决于方法的实现
     *
     * @returns {string | undefined} The localized name of the enum collection, or undefined if not
     *   set.
     */
    get name() {
        var _a, _b, _c, _d, _e;
        if (typeof ((_a = this.__options__) === null || _a === void 0 ? void 0 : _a.name) === 'function') {
            return this.__options__.name(undefined);
        }
        const localize = (_c = (_b = this.__options__) === null || _b === void 0 ? void 0 : _b.localize) !== null && _c !== void 0 ? _c : global_config_1.localizer.localize;
        if (typeof localize === 'function') {
            return localize((_d = this.__options__) === null || _d === void 0 ? void 0 : _d.name);
        }
        return (_e = this.__options__) === null || _e === void 0 ? void 0 : _e.name;
    }
    label(keyOrValue) {
        return this.__items__.label(keyOrValue);
    }
    key(value) {
        return this.__items__.key(value);
    }
    raw(value) {
        if (value != null) {
            return this.__items__.raw(value);
        }
        else {
            return this.__items__.raw();
        }
    }
    has(keyOrValue) {
        return this.__items__.has(keyOrValue);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    findBy(...rest) {
        return this.__items__.findBy(...rest);
    }
    toList(config) {
        return this.__items__.toList(config);
    }
    toMap(config) {
        return this.__items__.toMap(config);
    }
    get valueType() {
        return this.__items__.valueType;
    }
    get keyType() {
        return this.__items__.keyType;
    }
    get rawType() {
        return this.__items__.rawType;
    }
}
exports.EnumCollectionClass = EnumCollectionClass;
//# sourceMappingURL=enum-collection.js.map