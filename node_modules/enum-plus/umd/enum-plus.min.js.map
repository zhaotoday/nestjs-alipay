{"version":3,"file":"enum-plus.min.js","mappings":"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","sources":["webpack://EnumPlus/webpack/universalModuleDefinition","webpack://EnumPlus/webpack/bootstrap","webpack://EnumPlus/webpack/runtime/define property getters","webpack://EnumPlus/webpack/runtime/hasOwnProperty shorthand","webpack://EnumPlus/webpack/runtime/make namespace object","webpack://EnumPlus/./src/version.ts","webpack://EnumPlus/./src/utils.ts","webpack://EnumPlus/./src/global-config.ts","webpack://EnumPlus/./src/enum-item.ts","webpack://EnumPlus/./src/enum-items.ts","webpack://EnumPlus/./src/enum-collection.ts","webpack://EnumPlus/./src/enum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EnumPlus\"] = factory();\n\telse\n\t\troot[\"EnumPlus\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const version = '3.1.6';\n","import type { LocalizeInterface } from './localize-interface';\n\n/**\n * - **EN:** Alias of `items`. If the enum contains a field with the same name as `items`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举`items`集合的别名。如果枚举中包含了`items`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const ITEMS = Symbol.for('[items]');\n\n/**\n * - **EN:** Alias of `keys`. If the enum contains a field with the same name as `keys`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举keys集合的别名。如果枚举中包含了`keys`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const KEYS = Symbol.for('[keys]');\n\n/**\n * - **EN:** Alias of `values`. If the enum contains a field with the same name as `values`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举values集合的别名。如果枚举中包含了`values`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const VALUES = Symbol.for('[values]');\n\n/**\n * - **EN:** Alias of `labels`. If the enum contains a field with the same name as `labels`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举labels集合的别名。如果枚举中包含了`labels`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const LABELS = Symbol.for('[labels]');\n\n/**\n * - **EN:** Alias of `raw`. If the enum contains a field with the same name as `raw`, you can access\n *   it by this Symbol as the field name\n * - **CN:** 枚举raw集合的别名。如果枚举中包含了`raw`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const RAW = Symbol.for('[raw]');\n\nexport const ENUM_OPTIONS = Symbol.for('[EnumOptions]');\n\n/**\n * - **EN:** Alias of `meta`. If the enum contains a field with the same name as `meta`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举`meta`集合的别名。如果枚举中包含了`meta`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const META = Symbol.for('[meta]');\n\n/**\n * - **EN:** Alias of `named`. If the enum contains a field with the same name as `named`, you can\n *   access it by this Symbol as the field name\n * - **CN:** 枚举`named`集合的别名。如果枚举中包含了`named`的同名字段，可以通过此Symbol作为字段名来访问\n */\nexport const NAMED = Symbol.for('[named]');\n\n/**\n * - **CN:** 判断对象是否 `EnumItem` 实例\n * - **EN:** Check whether the object is an `EnumItem` instance\n */\nexport const IS_ENUM_ITEM = Symbol.for('[IsEnumItem]');\n\n/**\n * - **EN:** Check whether the object is an enum type\n * - **CN:** 判断对象是否枚举类型\n */\nexport const IS_ENUM = Symbol.for('[IsEnum]');\n\n/**\n * - **EN:** Check whether the object is an `EnumItems` collection array\n * - **CN:** 判断对象是否 `EnumItems` 集合数组\n */\nexport const IS_ENUM_ITEMS = Symbol.for('[IsEnumItems]');\n\n/**\n * - **EN:** Default global localization function, only used to resolve built-in resources into\n *   English, does not provide actual localization functions\n * - **CN:** 默认的全局本地化函数，仅用于将内置资源解析为英文，并不提供实际的本地化功能\n */\nexport const defaultLocalize: LocalizeInterface = (content): string | undefined => {\n  return content;\n};\n","import type { LocalizeInterface } from './localize-interface';\nimport { defaultLocalize } from './utils';\n\nexport const localizer: {\n  /**\n   * - **EN:** Convert resource key to localized text\n   * - **CN:** 把资源键值转化为本地化文本\n   */\n  localize?: LocalizeInterface;\n} = {\n  localize: defaultLocalize,\n};\n/** Internal module, do not use. */\nexport const internalConfig: {\n  autoLabel?:\n    | boolean\n    | ((options: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        item: any;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        labelPrefix: any;\n      }) => string);\n} = {\n  autoLabel: true,\n};\n","import { internalConfig, localizer } from './global-config';\nimport type {\n  EnumItemInit,\n  EnumItemLabel,\n  EnumKey,\n  EnumValue,\n  LocalizeInterface,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { IS_ENUM_ITEM } from './utils';\n\n/**\n * - **EN:** Represents a single item in an enumeration collection.\n * - **CN:** 表示枚举集合中的单个枚举项\n *\n * @template T Represents the type of the enum item's initialization object | 表示枚举项初始化对象的类型\n * @template V Represents the type of the enum item's value (usually string or number) |\n *   表示枚举项值的类型（通常是字符串或数字）\n * @template K Represents the type of the enum item's key | 表示枚举项键的类型\n */\nexport class EnumItemClass<\n  const T extends EnumItemInit<V>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  K extends EnumKey<any> = string,\n  V extends EnumValue = ValueTypeFromSingleInit<T, K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const P = any,\n> {\n  private _options: EnumItemOptions<T, K, V, P> | undefined;\n  private _label: EnumItemLabel | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _localize: (content: string | undefined) => any;\n\n  /**\n   * - **EN:** Creates an instance of EnumItemClass.\n   * - **CN:** 创建 EnumItemClass 的实例\n   *\n   * @param key The key of the enum item | 枚举项键\n   * @param value The value of the enum item | 枚举项值\n   * @param label The display name of the enum item | 枚举项显示名称\n   * @param raw The original initialization object | 原始初始化对象\n   * @param options Optional settings for the enum item | 枚举项的可选设置\n   */\n  constructor(key: K, value: V, label: EnumItemLabel, raw: T, options?: EnumItemOptions<T, K, V, P>) {\n    this.key = key;\n    this.value = value;\n    this.label = label as string;\n    this.raw = raw;\n\n    // Should use _label instead of label closure, to make sure it can be serialized correctly\n    Object.defineProperty(this, '_label', {\n      value: label,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n    // Use defineProperties instead of direct field, to:\n    // 1. Make fields readonly\n    // 2. Preserve getters after serialized/deserialized\n    Object.defineProperties(this, {\n      value: {\n        value,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      },\n      label: {\n        get: function (this: EnumItemClass<T, K, V, P>) {\n          const labelPrefix = this._options?.labelPrefix;\n          const autoLabel = this._options?.autoLabel ?? internalConfig.autoLabel;\n          let localeKey = this._label;\n          if (typeof localeKey === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return localeKey(this as any);\n          }\n          if (autoLabel && labelPrefix != null) {\n            if (typeof autoLabel === 'function') {\n              localeKey = autoLabel({\n                item: this,\n                labelPrefix: labelPrefix as P,\n              });\n            } else {\n              localeKey = `${labelPrefix as string}${this._label}`;\n            }\n          }\n          return this._localize(localeKey) ?? localeKey;\n        },\n        enumerable: true,\n        configurable: false,\n      },\n      key: {\n        value: key,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      },\n      raw: {\n        value: raw,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      },\n    });\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '_options', {\n      value: options,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n    this._localize = undefined!;\n    Object.defineProperty(this, '_localize', {\n      value: function (this: EnumItemClass<T, K, V, P>, content: string | undefined) {\n        const localize = this._options?.localize ?? localizer.localize;\n        if (typeof localize === 'function') {\n          return localize(content);\n        }\n        return content;\n      },\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    Object.freeze(this);\n  }\n\n  /**\n   * - **EN:** The value of the enum item\n   * - **CN:** 枚举项的值\n   */\n  readonly value: V;\n\n  /**\n   * - **EN:** The label of the enum item (also known as display name)\n   * - **CN:** 枚举项的标签（亦称显示名称）\n   */\n  readonly label: string;\n\n  /**\n   * - **EN:** The key of the enum item, which is the key in the initialization object when creating\n   *   the enum collection.\n   * - **CN:** 枚举项的键，即创建枚举集合时初始化对象中的键\n   */\n  readonly key: K;\n\n  /**\n   * - **EN:** The original initialization object of the enum item, which is the sub-object of a\n   *   single enum item when creating the enum collection.\n   * - **CN:** 枚举项的原始初始化对象，即创建枚举集合时单个枚举项的子对象\n   */\n  readonly raw: T;\n  /**\n   * - **EN:** A boolean value indicates that this is an enum item instance.\n   * - **CN:** 布尔值，表示这是一个枚举项实例\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM_ITEM](): true {\n    return true;\n  }\n  /**\n   * - **EN:** Auto convert to a correct primitive type. This method is called when the object is used\n   *   in a context that requires a primitive value.\n   *\n   * > The priority of this method is higher than both `valueOf` and `toString` methods.\n   *\n   * - **CN:** 自动转换为正确的原始类型。当对象被用在需要原始值的上下文中时会调用此方法。\n   *\n   * > 此方法的优先级高于 `valueOf` 和 `toString` 方法。\n   *\n   * @param hint {'number' | 'string' | 'default'} - A string indicating the preferred type of the\n   *   result | 指示结果的首选类型\n   *\n   * @returns The primitive value of the enum item, either its value or label based on the hint |\n   *   枚举项的原始值，根据提示返回其值或标签\n   */\n  // @ts-expect-error: because don't want show `Symbol` in vscode's intellisense, it should work in background\n  private [Symbol.toPrimitive](this: EnumItemClass<T, K, V>, hint: 'number' | 'string' | 'default'): V | string {\n    if (hint === 'number') {\n      // for the cases like Number(value) or +value\n      return this.valueOf();\n    } else if (hint === 'string') {\n      // for the cases like String(value), `${value}`\n      return this.toString();\n    }\n    // for the cases like '' + value, value == 1\n    return this.valueOf();\n  }\n\n  /**\n   * - **EN:** Returns the string representation of the enum item, which is its label. This method is\n   *   called when the object is used in a context that requires a string value, such as string\n   *   concatenation or template literals.\n   *\n   * > The priority of this method is lower than the `valueOf` method\n   *\n   * - **CN:** 返回枚举项的字符串表示形式，即其显示名称。当对象被用在需要字符串值的上下文中时会调用此方法，例如字符串连接或模板字面量。\n   *\n   * > 此方法的优先级低于 `valueOf` 方法\n   *\n   * @returns The display name of the enum item | 枚举项的显示名称\n   */\n  toString() {\n    return this.label;\n  }\n  /**\n   * - **EN:** Returns the localized string representation of the enum item, which is its label. This\n   *   method is called when the object is used in a context that requires a localized string value,\n   *   such as `toLocaleString` method.\n   * - **CN:** 返回枚举项的本地化字符串表示形式，即其显示名称。当对象被用在需要本地化字符串值的上下文中时会调用此方法，例如 `toLocaleString` 方法。\n   *\n   * @returns The localized display name of the enum item | 枚举项的本地化显示名称\n   */\n  toLocaleString() {\n    return this.toString();\n  }\n  /**\n   * - **EN:** Returns the primitive value of the enum item, which is its value. This method is called\n   *   when the object is used in a context that requires a primitive value, such as mathematical\n   *   operations.\n   *\n   * > The priority of this method is higher than the `toString` method\n   *\n   * - **CN:** 返回枚举项的原始值，即其值。当对象被用在需要原始值的上下文中时会调用此方法，例如数学运算。\n   *\n   * > 此方法的优先级高于 `toString` 方法\n   *\n   * @returns The value of the enum item | 枚举项的值\n   */\n  valueOf() {\n    return this.value;\n  }\n}\n\nexport interface EnumItemOptions<\n  T extends EnumItemInit<V>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  K extends EnumKey<any> = string,\n  V extends EnumValue = ValueTypeFromSingleInit<T, K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** Localization function, used to convert the text of the enumeration item to localized\n   *   text\n   * - **CN:** 本地化函数，用于把枚举项文本转换为本地化文本\n   */\n  localize?: LocalizeInterface;\n  /**\n   * - **EN:** The label prefix for each enum item, which can be a string or an object. This option\n   *   can simplify or even omit the label definition of enum items, and is only effective when\n   *   internationalization is enabled.\n   * - **CN:** 每个枚举项的label前缀，可以是字符串，也可以是一个对象。此选项可以简化甚至省略枚举项的label定义，只有当开启国际化时才需要此选项。\n   */\n  labelPrefix?: P;\n\n  /**\n   * - **EN:** Allow setting a label prefix for enum items, simplifying or even omitting the label\n   *   definition of enum items. This option is only needed when internationalization is enabled.\n   *   The prefix is set through `options.labelPrefix` when creating the Enum, which can be a string\n   *   or an object.\n   *\n   *   - `true` - Default value. Enable automatic concatenation of enum item localeKey in\n   *       `options.labelPrefix` + `label` format. `labelPrefix` only supports string in this case.\n   *   - `Function` - Dynamically generate the localeKey for enum items. `labelPrefix` supports any type\n   *       in this case.\n   *   - `false` - Disable automatic label generation, completely relying on the `label` field defined\n   *       in the enum item.\n   *\n   * > This option has the same effect as `Enum.config.autoLabel`, but has a higher priority than the\n   * > global configuration, and only takes effect for the current enum instance.\n   *\n   * - **CN:** 允许为枚举项设置label前缀，简化甚至可以省略枚举项的label定义，只有当开启国际化时才需要此选项。创建Enum时通过 `options.labelPrefix`\n   *   设置前缀，可以是字符串，也可以是一个对象。\n   *\n   *   - `true` - 默认值，启用自动拼接，`options.labelPrefix` + `label` 自动拼接生成标签，这种情况下 `labelPrefix` 只支持字符串形式\n   *   - `Function` - 动态生成枚举项localeKey，这种情况下 `labelPrefix` 支持任意类型\n   *   - `false` - 禁用自动生成标签，完全依赖枚举项中定义的 `label` 字段\n   *\n   * > 此选项与 `Enum.config.autoLabel` 作用相同，但优先级高于全局配置，仅对当前枚举实例生效。\n   */\n  autoLabel?: boolean | ((options: { item: EnumItemClass<T, K, V, P>; labelPrefix: P }) => string);\n}\n","import type { EnumItemOptions } from './enum-item';\nimport { EnumItemClass } from './enum-item';\nimport type {\n  EnumInit,\n  EnumItemInit,\n  EnumItemLabel,\n  EnumKey,\n  EnumValue,\n  ExactEqual,\n  FindEnumKeyByValue,\n  FindKeyByMeta,\n  FindLabelByValue,\n  FindValueByKey,\n  FindValueByMeta,\n  ListItem,\n  PrimitiveOf,\n  StandardEnumItemInit,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { IS_ENUM_ITEMS, KEYS, VALUES } from './utils';\n\n/**\n * Enum items array, mostly are simple wrappers for EnumCollectionClass\n *\n * @template T Type of the initialization data of the enum collection\n *\n * @class EnumItemsArray\n *\n * @extends {EnumItemClass<T, K, V>[]}\n *\n * @implements {IEnumItems<T, K, V>}\n */\nexport class EnumItemsArray<\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n  >\n  extends Array<EnumItemClass<T[K], K, V, P>>\n  implements IEnumItems<T, K, V, P>\n{\n  private __raw__!: T;\n  /**\n   * - **EN:** A boolean value indicates that this is an enum items array.\n   * - **CN:** 布尔值，表示这是一个枚举项数组\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM_ITEMS](): true {\n    return true;\n  }\n  readonly [KEYS]!: K[];\n  readonly [VALUES]!: V[];\n  readonly labels!: string[];\n  readonly named!: {\n    [key in keyof T]: EnumItemClass<\n      // @ts-expect-error: because the first type parameter T is a union type, T[key] cannot satisfy each one of T.\n      T[key],\n      key,\n      ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>,\n      P\n    >;\n  };\n  readonly meta!: IEnumItems<T, K, V, P>['meta'];\n  private _runtimeError: (name: string) => string;\n\n  /**\n   * Instantiate an enum items array\n   *\n   * @memberof EnumItemsArray\n   *\n   * @param {T} raw Original initialization data object\n   * @param {EnumItemOptions<T[K], K, V, P> | undefined} options Enum item options\n   */\n  constructor(raw: T, options: EnumItemOptions<T[K], K, V, P> | undefined) {\n    super();\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '__raw__', {\n      value: raw,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n\n    // Generate keys array\n    // exclude number keys with a \"reverse mapping\" value, it means those \"reverse mapping\" keys of number enums\n    const keys = parseKeys<T, K, V>(raw);\n    const parsed = keys.map((key) => parseEnumItem<EnumItemInit<V>, K, V>(raw[key], key));\n    this[KEYS] = keys;\n    Object.freeze(keys);\n\n    const items: EnumItemClass<T[K], K, V, P>[] = [];\n    const meta = {} as { [K in Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>]: T[keyof T][K][] };\n    this.meta = meta as IEnumItems<T, K, V, P>['meta'];\n    const named = {} as Record<K, EnumItemClass<T[K], K, V, P>>;\n    this.named = named as IEnumItems<T, K, V, P>['named'];\n    keys.forEach((key, index) => {\n      const { value, label } = parsed[index];\n      const item = new EnumItemClass<T[K], K, V, P>(key, value, label, raw[key], options);\n      items.push(item);\n      this.push(item);\n      named[key] = item;\n\n      // Collect custom meta fields\n      const itemRaw = raw[key];\n      if (itemRaw && typeof itemRaw === 'object') {\n        Object.keys(itemRaw).forEach((k) => {\n          const metaKey = k as Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>;\n          if (metaKey !== 'key' && metaKey !== 'value' && metaKey !== 'label') {\n            if (meta[metaKey] == null) {\n              meta[metaKey] = [];\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const metaValue = (itemRaw as any)[metaKey];\n            if (metaValue != null) {\n              meta[metaKey].push(metaValue);\n            }\n          }\n        });\n      }\n    });\n    // Freeze meta arrays\n    Object.keys(meta).forEach((k) => {\n      Object.freeze(meta[k as keyof typeof meta]);\n    });\n\n    // Generate values array\n    const values = parsed.map((item) => item.value);\n    this[VALUES] = values;\n    Object.freeze(values);\n\n    // Generate labels array\n    Object.defineProperty(this, 'labels', {\n      get: function (this: EnumItemsArray<T, K, V, P>) {\n        // Cannot save to static array because labels may be localized contents\n        // Should not use `items` in the closure because the getter function cannot be fully serialized\n        return Array.from(this).map((item) => item.label);\n      },\n      enumerable: true,\n      configurable: false,\n    });\n\n    this._runtimeError = undefined!;\n    Object.defineProperty(this, '_runtimeError', {\n      value: function (this: EnumItemsArray<T, K, V, P>, name: string) {\n        return `The ${name} property of the enumeration is only allowed to be used to declare the ts type, and cannot be accessed at runtime! Please use the typeof operator in the ts type, for example: typeof Week.${name}`;\n      },\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n  }\n\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V> {\n    // intentionally use == to support both number and string format value\n    return this.some(\n      // eslint-disable-next-line eqeqeq\n      (i) => (instance as unknown as V) == i.value || (instance as unknown as K) === i.key\n    );\n  }\n\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>] extends { label: unknown }\n            ? T[NonNullable<KV>]['label'] extends undefined\n              ? NonNullable<KV>\n              : string\n            : NonNullable<KV>\n          : NonNullable<KV> extends V\n            ? FindLabelByValue<T, NonNullable<KV>>\n            : PrimitiveOf<K> extends KV\n              ? string | undefined\n              : PrimitiveOf<V> extends KV\n                ? string | undefined\n                : undefined) {\n    // Find by value, then try key\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.find((i) => i.value === keyOrValue) ?? this.find((i) => i.key === keyOrValue))?.label as any;\n  }\n\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(\n    value?: IV\n  ):\n    | (undefined extends IV ? undefined : never)\n    | (IV extends undefined\n        ? undefined\n        : NonNullable<IV> extends V\n          ? FindEnumKeyByValue<T, NonNullable<IV>>\n          : PrimitiveOf<V> extends NonNullable<IV>\n            ? K | undefined\n            : undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this.find((i) => i.value === value)?.key as any;\n  }\n\n  raw(): T;\n  raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(\n    keyOrValue: IK\n  ): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;\n  raw<IK extends EnumValue>(keyOrValue?: IK | unknown): T | T[K] | T[FindEnumKeyByValue<T, IK>] | undefined {\n    if (keyOrValue == null) {\n      // Return the original initialization object\n      return this.__raw__;\n    } else {\n      // Find by key\n      if (Object.keys(this.__raw__).some((k) => k === keyOrValue)) {\n        return this.__raw__[keyOrValue as K];\n      }\n      // Find by value\n      const itemByValue = this.find((i) => i.value === keyOrValue);\n      if (itemByValue) {\n        return itemByValue.raw;\n      }\n      return undefined;\n    }\n  }\n\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V> {\n    return this.some((i) => i.value === (keyOrValue as unknown as V) || i.key === (keyOrValue as unknown as K));\n  }\n\n  findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, FV>(\n    field: FK,\n    value: FV\n  ): FK extends 'key'\n    ? FV extends K\n      ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of K\n        EnumItemClass<T[FV], FV, FindValueByKey<T, FV>>\n      : EnumItemClass<T[K], K, V, P> | undefined\n    : FK extends 'value'\n      ? FV extends V\n        ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of V\n          EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV>\n        : EnumItemClass<T[K], K, V, P> | undefined\n      : FK extends 'label'\n        ? EnumItemClass<T[K], K, V, P> | undefined\n        : // @ts-expect-error: because the type infer is not clever enough, FK here should be one of keyof Raw\n          FV extends T[keyof T][FK]\n          ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of T[keyof T][FK]\n            EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>>\n          : EnumItemClass<T[K], K, V, P> | undefined {\n    return this.find((item) => {\n      if (field === 'key' || field === 'value') {\n        return item[field as keyof typeof item] === value;\n      } else if (field === 'label') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item.raw as any)?.label === value || item.label === value;\n      } else {\n        // For other fields, use the raw object to find\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item.raw as any)?.[field] === value;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }) as any;\n  }\n\n  toList(): ListItem<V, 'value', 'label'>[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n    R\n  >[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config?: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ):\n    | ListItem<V, 'value', 'label'>[]\n    | ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n        R\n      >[] {\n    const { valueField = 'value' as FOV, labelField = 'label' as FOL, extra } = config ?? {};\n    return Array.from(this).map((item) => {\n      const valueFieldName = typeof valueField === 'function' ? valueField(item) : (valueField as string);\n      const labelFieldName = typeof labelField === 'function' ? labelField(item) : (labelField as string);\n      const extraData = extra ? (extra(item) as R) : ({} as R);\n      const listItem = {\n        [valueFieldName]: item.value,\n        [labelFieldName]: item.label,\n        ...extraData,\n      } as ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n        R\n      >;\n      return listItem;\n    });\n  }\n\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(config?: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P> {\n    if (!config) {\n      return this.reduce(\n        (prev, cur) => {\n          prev[cur.value] = cur.label;\n          return prev;\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any\n      ) as unknown as MapResult<T, KS, VS, K, V, P>;\n    }\n    const { keySelector = 'value', valueSelector = 'label' } = config;\n    return this.reduce(\n      (prev, cur) => {\n        let key: string | symbol;\n        if (typeof keySelector === 'function') {\n          key = keySelector(cur);\n        } else {\n          key = cur[keySelector as keyof EnumItemClass<T[K], K, V, P>] as string | symbol;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let value: any;\n        if (typeof valueSelector === 'function') {\n          value = valueSelector(cur);\n        } else {\n          value = cur[valueSelector as keyof EnumItemClass<T[K], K, V, P>] as unknown;\n        }\n        prev[key as keyof MapResult<T, KS, VS, K, V, P>] = value;\n        return prev;\n      },\n      {} as MapResult<T, KS, VS, K, V, P>\n    ) as unknown as MapResult<T, KS, VS, K, V, P>;\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get valueType(): V {\n    throw new Error(this._runtimeError('valueType'));\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get keyType(): K {\n    throw new Error(this._runtimeError('keyType'));\n  }\n\n  /** Stub method, only for typing usages, not for runtime calling */\n  get rawType(): T[K] {\n    throw new Error(this._runtimeError('rawType'));\n  }\n}\n\n/**\n * - **EN:** Enum item collection interface, excluding members inherited from the array\n * - **CN:** 枚举项集合接口，不包含从数组集成的成员\n *\n * @template T The type of enum initialization | 枚举初始化的类型\n * @template K The type of enum keys | 枚举键的类型\n * @template V The type of enum values | 枚举值的类型\n *\n * @interface IEnumItems\n */\nexport interface IEnumItems<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> extends InheritableEnumItems<T, K, V, P> {\n  /**\n   * - **EN:** A boolean value indicates that this is an enum items array.\n   * - **CN:** 布尔值，表示这是一个枚举项数组\n   */\n  [IS_ENUM_ITEMS]: true;\n  /**\n   * - **EN:** Get all keys of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部keys列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  readonly [KEYS]: K[];\n  /**\n   * - **EN:** Get all values of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部values列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  readonly [VALUES]: V[];\n  /**\n   * - **EN:** Get all labels of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部labels列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  readonly labels: string[];\n\n  /**\n   * - **EN:** A mapping of enum keys to their corresponding enum item classes. This is useful for\n   *   quick access to specific enum items.\n   * - **CN:** 枚举键到其对应的枚举项类的映射，对于快速访问枚举项非常有用\n   */\n  named: {\n    [key in keyof T]: EnumItemClass<\n      // @ts-expect-error: because the first type parameter T is a union type, T[key] cannot satisfy each one of T.\n      T[key],\n      key,\n      ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>,\n      P\n    >;\n  };\n\n  /**\n   * - **EN:** Get all custom meta fields of the enumeration items as an object, where the keys are\n   *   the field names, and values are the raw values of each field\n   * - **CN:** 获取枚举项的全部自定义元字段，返回一个对象，其中key为字段名，value为每个字段的原始值数组\n   */\n  readonly meta: T extends object\n    ? { [K in Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>]: T[keyof T][K][] }\n    : // eslint-disable-next-line @typescript-eslint/ban-types\n      {};\n}\n\n// typeof IS_ENUM_ITEMS | typeof ITEMS | typeof KEYS | typeof VALUES | 'labels' | 'meta' | 'named'\nexport interface InheritableEnumItems<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** A method that determines if a constructor object recognizes an object as one of the\n   *   constructor’s instances. Called by the semantics of the `instanceof` operator.\n   * - **CN:** 一个方法，用于确定构造函数对象是否将对象识别为构造函数的实例之一。由 `instanceof` 运算符的语义调用。\n   */\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V>;\n  /**\n   * - **EN:** The enum collection name, supports localization.\n   *\n   * > Note that it usually returns a string, but if a custom `localize` function is set, the return\n   * > value may vary depending on the implementation of the method.\n   *\n   * - **CN:** 枚举集合显示名称，支持本地化。\n   *\n   * > 注意，通常情况下返回的是字符串，但如果设置了自定义的 `localize` 函数，则返回值可能有所不同，取决于方法的实现\n   *\n   * @returns {string | undefined} The localized name of the enum collection, or undefined if not\n   *   set | 枚举集合的本地化名称，如果未设置则为 undefined\n   */\n  readonly name?: string;\n  /**\n   * - **EN:** Get the label (also known as display name) of the enumeration item, supports getting by\n   *   value or key\n   * - **CN:** 获取枚举项的标签（亦称显示名称），支持通过枚举项的 value 或 key 获取\n   *\n   * @param keyOrValue - The value or key of the enumeration item | 枚举项的 value 或 key\n   *\n   * @returns The label of the enumeration item or the key if the label is not defined | 枚举项的标签或\n   *   key（如果标签未定义）\n   */\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>] extends { label: unknown }\n            ? T[NonNullable<KV>]['label'] extends undefined\n              ? NonNullable<KV>\n              : string\n            : NonNullable<KV>\n          : NonNullable<KV> extends V\n            ? FindLabelByValue<T, NonNullable<KV>>\n            : PrimitiveOf<K> extends KV\n              ? string | undefined\n              : PrimitiveOf<V> extends KV\n                ? string | undefined\n                : undefined);\n\n  /**\n   * - **EN:** Get the key of the enumeration item by its value\n   * - **CN:** 根据枚举项的 value 获取其 key\n   *\n   * @param value The value of the enumeration item | 枚举项的 value\n   *\n   * @returns The key of the enumeration item, or undefined if not found | 枚举项的 key，如果未找到则返回\n   *   undefined\n   */\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(\n    value: IV\n  ):\n    | (undefined extends IV ? undefined : never)\n    | (IV extends undefined\n        ? undefined\n        : NonNullable<IV> extends V\n          ? FindEnumKeyByValue<T, NonNullable<IV>>\n          : PrimitiveOf<V> extends NonNullable<IV>\n            ? K | undefined\n            : undefined);\n\n  /**\n   * - **EN:** Get the enumeration item by key or value\n   * - **CN:** 获取枚举集合的初始化对象\n   *\n   * @returns {T} Enum collection initialization object | 初始化对象集合\n   */\n  raw(): T;\n  /**\n   * - **EN:** Get the original initialization object of a certain enumeration item. If custom fields\n   *   are added to the enumeration item, you can use this method to get them.\n   * - **CN:** 获取某个枚举项的原始初始化对象。如果在枚举项上增加了自定义字段的话，可以用这种方式获取到。\n   *\n   * @param keyOrValue Enum key or value | 枚举key或value\n   *\n   * @returns The original initialization object of the enumeration item, or undefined if not found\n   *   | 枚举项的原始初始化对象，如果未找到则返回 undefined\n   */\n  raw<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(\n    keyOrValue: KV\n  ):\n    | (undefined extends KV ? undefined : never)\n    | (KV extends undefined\n        ? undefined\n        : NonNullable<KV> extends K\n          ? T[NonNullable<KV>]\n          : NonNullable<KV> extends V\n            ? T[FindEnumKeyByValue<T, NonNullable<KV>>]\n            : PrimitiveOf<K> extends KV\n              ? T[K] | undefined\n              : PrimitiveOf<V> extends KV\n                ? T[K] | undefined\n                : undefined);\n  /**\n   * - **EN:** Get the value corresponding to a certain enumeration item\n   * - **CN:** 判断某个枚举项是否存在\n   *\n   * @param keyOrValue Enum item key or value | 枚举项的key或value\n   *\n   * @returns {boolean} Whether the enumeration item exists | 枚举项是否存在\n   */\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V>;\n\n  /**\n   * **EN:** Find an enumeration item by key or value, or by custom meta fields\n   *\n   * **CN:** 通过key或value查找枚举项，或通过自定义元字段查找\n   *\n   * @param field The field to search by | 要查找的字段\n   * @param value The value to search | 要查找的值\n   *\n   * @returns The found enumeration item or `undefined` if not found | 找到的枚举项，如果未找到则返回 `undefined`\n   */\n  findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, const FV>(\n    field: FK,\n    value: FV\n  ): FK extends 'key'\n    ? FV extends K\n      ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of K\n        EnumItemClass<T[FV], FV, FindValueByKey<T, FV>>\n      : EnumItemClass<T[K], K, V, P> | undefined\n    : FK extends 'value'\n      ? FV extends V\n        ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of V\n          EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV>\n        : EnumItemClass<T[K], K, V, P> | undefined\n      : FK extends 'label'\n        ? EnumItemClass<T[K], K, V, P> | undefined\n        : // @ts-expect-error: because the type infer is not clever enough, FK here should be one of keyof Raw\n          FV extends T[keyof T][FK]\n          ? // @ts-expect-error: because the type infer is not clever enough, FV here should be one of T[keyof T][FK]\n            EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>>\n          : EnumItemClass<T[K], K, V, P> | undefined;\n\n  /**\n   * - **EN:** Generate an object array containing all enumeration items\n   * - **CN:** 生成一个对象数组，包含所有的枚举项\n   *\n   * @example\n   *   [\n   *     { value: 0, label: 'Sunday' },\n   *     { value: 1, label: 'Monday' },\n   *   ];\n   *\n   * @returns An object array of all enumeration items | 所有枚举项的对象数组\n   */\n  toList(): ListItem<V, 'value', 'label'>[];\n  /**\n   * - **EN:** Generate an object array containing all enumeration items, with customizable value and\n   *   label field names\n   * - **CN:** 生成一个对象数组，包含所有的枚举项，可自定义值和标签字段名\n   *\n   * @example\n   *   Week.toList({\n   *     valueField: 'id',\n   *     labelField: 'name',\n   *   });\n   *\n   *   [\n   *     { id: 0, name: 'Sunday' },\n   *     { id: 1, name: 'Monday' },\n   *   ];\n   *\n   * @param config Custom options, supports customizing value and label field names |\n   *   自定义选项，支持自定义值和标签字段名\n   *\n   * @returns An object array of all enumeration items in the specified value and label fields |\n   *   所有枚举项的对象数组，按照指定的值和标签字段格式\n   */\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    R extends Record<string, unknown> = never,\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, R, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL,\n    R\n  >[];\n\n  /**\n   * - **EN:** Generate a mapping object of all enum items, where the keys are the values of the enum\n   *   and the values are the labels of the enum\n   * - **CN:** 生成一个映射对象，包含所有的枚举项，key为枚举值，value为枚举标签\n   *\n   * @example\n   *   {\n   *     \"0\": \"Sunday\",\n   *     \"1\": \"Monday\"\n   *   }\n   *\n   * @returns A mapping object of all enum items | 所有枚举项的映射对象\n   */\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  /**\n   * - **EN:** Generate a mapping object of all enum items, with customizable key and value fields\n   * - **CN:** 生成一个映射对象，包含所有的枚举项，可自定义键和值字段\n   *\n   * @example\n   *   Week.toMap({ key: 'value', value: 'label' });\n   *\n   *   ({ '0': 'Sunday', '1': 'Monday' });\n   *\n   *   /// Allow custom function, and meta fields can be used\n   *   Week.toMap({\n   *     key: 'key',\n   *     value: (item) => ({ id: item.value, name: item.label, foo: item.raw.foo }),\n   *   });\n   *\n   *   ({\n   *     Sunday: { id: 0, name: 'Sunday', foo: 'bar' },\n   *     Monday: { id: 1, name: 'Monday', foo: 'b' },\n   *   });\n   *\n   * @param config Custom options, supports customizing key and value fields | 自定义选项，支持自定义键和值字段\n   *\n   * @returns A mapping object of all enum items in the specified key and value fields |\n   *   所有枚举项的映射对象，按照指定的键和值字段格式\n   */\n  toMap<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    FOK extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    FOV extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  >(\n    config: ToMapConfig<T, FOK, FOV, K, V, P>\n  ): MapResult<T, FOK, FOV, K, V, P>;\n\n  /**\n   * - **EN:** The data type of all enumeration values\n   *\n   * > 📣 Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** 所有枚举值的数据类型\n   *\n   * > 📣 注意：仅可作为类型声明使用，不可在运行时调用\n   *\n   * @example\n   *   // Declare the type of the variable | 声明变量的类型\n   *   const week: typeof Week.valueType = Week.Monday; // 0\n   *\n   *   // Declare type field | 声明类型字段\n   *   type Props = {\n   *     week: typeof Week.valueType; // 0 | 1\n   *   };\n   */\n  valueType: V;\n\n  /**\n   * - **EN:** The data type of all enumeration keys\n   *\n   * > 📣 Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** 所有枚举key的数据类型\n   *\n   * > 📣 注意：仅可作为类型声明使用，不可在运行时调用\n   *\n   * @example\n   *   // Declare the type of the variable | 声明变量的类型\n   *   const weekName: typeof Week.keyType = 'Sunday'; // \"Sunday\" | \"Monday\"\n   *\n   *   // Declare type field | 声明类型字段\n   *   type Props = {\n   *     weekName: typeof Week.keyType; // \"Sunday\" | \"Monday\"\n   *   };\n   */\n  keyType: K;\n\n  /**\n   * - **EN:** The type of the original initialization object of the enumeration item. If custom\n   *   fields are added to the enumeration item, you can use this method to get them.\n   *\n   * > 📣 Note: Can only be used as a type declaration, cannot be called at runtime\n   *\n   * - **CN:** 枚举项原始初始化对象的类型，如果在枚举项上增加了自定义字段的话，可以用这种方式获取到。\n   *\n   * > 📣 注意：仅可作为类型声明使用，不可在运行时调用\n   */\n  rawType: T[K];\n}\n\n/** More options for the options method */\nexport interface ToListConfig<\n  T extends EnumInit<K, V>,\n  FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  R extends Record<string, unknown> = never,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** The name of the value field in the output object, or a function to get the field name,\n   *   default is `value`\n   * - **CN:** 输出对象的value字段名，或者获取字段名的函数，默认为 `value`\n   */\n  valueField?: FOV;\n  /**\n   * - **EN:** The name of the label field in the output object, or a function to get the field name,\n   *   default is `label`\n   * - **CN:** 输出对象的label字段名，或者获取字段名的函数，默认为 `label`\n   */\n  labelField?: FOL;\n  /**\n   * - **EN:** A function to add extra fields to each item in the output object\n   * - **CN:** 一个函数，用于为输出对象中的每个项添加额外的字段\n   */\n  extra?: (item: EnumItemClass<T[K], K, V, P>) => R;\n}\n\nexport interface ToMapConfig<\n  T extends EnumInit<K, V>,\n  KS extends\n    | EnumItemFields\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> {\n  /**\n   * - **EN:** A field of `EnumItem` as the key of the output object, or a function to get the key of\n   *   items, default is `key`\n   * - **CN:** 作为输出对象key的`EnumItem`字段名，或者获取输出对象key的函数，默认为 `key`\n   */\n  keySelector?: KS;\n  /**\n   * - **EN:** A field of `EnumItem` as the value of the output object, or a function to get the value\n   *   of items, default is `value`\n   * - **CN:** 作为输出对象value的`EnumItem`字段名，或者获取输出对象value的函数，默认为 `value`\n   */\n  valueSelector?: VS;\n}\n\nexport type MapResult<\n  T extends EnumInit<K, V>,\n  KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol),\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any),\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> = {\n  [key in ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      EnumItemClass<T[K], K, V, P>['value'] & keyof any\n    : KS extends EnumItemFields\n      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        EnumItemClass<T[K], K, V, P>[KS] & keyof any\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        KS extends (item: any) => infer R\n        ? R\n        : never]: ExactEqual<VS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => unknown)> extends true\n    ? ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true\n      ? FindLabelByValue<T, key>\n      : EnumItemClass<T[K], K, V, P>['label']\n    : VS extends EnumItemFields\n      ? EnumItemClass<T[K], K, V, P>[VS]\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        VS extends (item?: any) => infer R\n        ? R\n        : never;\n};\n\nexport type EnumItemFields = Exclude<\n  {\n    [key in keyof EnumItemClass<StandardEnumItemInit<string>>]: EnumItemClass<\n      StandardEnumItemInit<string>\n    >[key] extends (...args: any[]) => unknown\n      ? never\n      : key;\n  }[keyof EnumItemClass<StandardEnumItemInit<string>>] &\n    string,\n  'raw'\n>;\n\nexport function parseKeys<\n  const T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n>(raw: EnumInit<K, V>) {\n  return Object.keys(raw).filter((k) => !(/^-?\\d+$/.test(k) && k === `${raw[raw[k as K] as K] ?? ''}`)) as K[];\n}\n\nfunction parseEnumItem<\n  T extends EnumItemInit<V>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  K extends EnumKey<any>,\n  V extends EnumValue,\n>(init: T, key: K): StandardEnumItemInit<V> {\n  let value: V;\n  let label: EnumItemLabel;\n  if (init != null) {\n    if (typeof init === 'number' || typeof init === 'string' || typeof init === 'symbol') {\n      value = init as V;\n      label = key as EnumItemLabel;\n    } else if (typeof init === 'object') {\n      // Initialize using object\n      if (Object.prototype.toString.call(init) === '[object Object]') {\n        if ('value' in init && Object.keys(init).some((k) => k === 'value')) {\n          // type of {value, label}\n          value = (init.value ?? key) as V;\n          if ('label' in init && Object.keys(init).some((k) => k === 'label')) {\n            label = init.label!;\n          } else {\n            label = key as EnumItemLabel;\n          }\n        } else if ('label' in init && Object.keys(init).some((k) => k === 'label')) {\n          // typeof {label}\n          value = key as unknown as V;\n          label = init.label ?? (key as EnumItemLabel);\n        } else {\n          // {} empty object\n          value = key as unknown as V;\n          label = key as EnumItemLabel;\n        }\n      } else {\n        // Probably Date, RegExp and other primitive types\n        value = init as V;\n        label = key as EnumItemLabel;\n      }\n    } else {\n      throw new Error(`Invalid enum item: ${JSON.stringify(init)}`);\n    }\n  } else {\n    value = key as unknown as V;\n    label = key as EnumItemLabel;\n  }\n  return { value, label };\n}\n","import type { EnumExtension } from 'enum-plus/extension';\nimport type { EnumInitOptions } from './enum';\nimport type { EnumItemClass, EnumItemOptions } from './enum-item';\nimport type { EnumItemFields, InheritableEnumItems, MapResult, ToListConfig, ToMapConfig } from './enum-items';\nimport { EnumItemsArray } from './enum-items';\nimport { localizer } from './global-config';\nimport type {\n  EnumInit,\n  EnumKey,\n  EnumValue,\n  FindEnumKeyByValue,\n  ListItem,\n  PrimitiveOf,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { ENUM_OPTIONS, IS_ENUM, ITEMS, KEYS, LABELS, META, NAMED, VALUES } from './utils';\n\n/**\n * - **EN:** Enum collection extension base class, used to extend the Enums\n * - **CN:** 枚举集合扩展基类，用于扩展枚举\n */\n// @ts-expect-error: because don't know which methods are added\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class EnumExtensionClass<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n> implements EnumExtension<T, K, V> {}\n\n/**\n * - **EN:** Enum collection\n * - **CN:** 枚举项集合\n */\nexport class EnumCollectionClass<\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n  >\n  extends EnumExtensionClass<T, K, V>\n  implements InheritableEnumItems<T, K, V, P>\n{\n  private readonly __options__: EnumInitOptions<T, K, V, P> | undefined;\n  // used for e2e serialization\n  private readonly __items__!: EnumItemsArray<T, K, V, P>;\n\n  constructor(init: T = {} as T, options?: EnumInitOptions<T, K, V, P>) {\n    super();\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '__options__', {\n      value: options,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    const keys = Object.keys(init) as K[];\n    // Generate enum items array\n    const items = new EnumItemsArray<T, K, V, P>(init, options);\n    Object.freeze(items);\n    // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken\n    this[keys.includes('items') ? ITEMS : 'items'] = items;\n    Object.defineProperty(this, '__items__', {\n      value: items,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // @ts-expect-error: because use KEYS to avoid naming conflicts in case of 'keys' field name is taken\n    this[keys.includes('keys') ? KEYS : 'keys'] = items[KEYS];\n\n    // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken\n    this[keys.includes('values') ? VALUES : 'values'] = items[VALUES];\n\n    // @ts-expect-error: because use NAMED to avoid naming conflicts in case of 'named' field name is taken\n    this[keys.includes('named') ? NAMED : 'named'] = items.named;\n\n    // @ts-expect-error: because use META to avoid naming conflicts in case of 'meta' field name is taken\n    this[keys.includes('meta') ? META : 'meta'] = items.meta;\n\n    // Add keys to the instance, allows picking enum values by keys\n    items.forEach((item) => {\n      // @ts-expect-error: because of dynamic property\n      this[item.key] = item.value;\n    });\n\n    // @ts-expect-error: because use LABELS to avoid naming conflicts in case of 'labels' field name is taken\n    Object.defineProperty(this, keys.includes('labels') ? LABELS : 'labels', {\n      enumerable: true,\n      configurable: false,\n      get: function (this: EnumCollectionClass<T, K, V, P>) {\n        return this.__items__.labels;\n      },\n    });\n\n    Object.freeze(this);\n  }\n  /**\n   * - **EN:** A boolean value indicates that this is an enum collection instance.\n   * - **CN:** 布尔值，表示这是一个枚举集合实例\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM](): true {\n    return true;\n  }\n  /**\n   * - **EN:** Get the options to initialize the enum.\n   * - **CN:** 获取初始化枚举时的选项\n   */\n  get [ENUM_OPTIONS](): EnumItemOptions<T[K], K, V, P> | undefined {\n    return this.__options__;\n  }\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V> {\n    return instance instanceof this.__items__;\n  }\n  /**\n   * The enum collection name, supports localization. Note that it usually returns a string, but if\n   * a custom `localize` function is set, the return value may vary depending on the implementation\n   * of the method.\n   *\n   * - **CN:** 枚举集合显示名称，支持本地化。注意，通常情况下返回的是字符串，但如果设置了自定义的 `localize` 函数，则返回值可能有所不同，取决于方法的实现\n   *\n   * @returns {string | undefined} The localized name of the enum collection, or undefined if not\n   *   set.\n   */\n  get name(): string | undefined {\n    if (typeof this.__options__?.name === 'function') {\n      return this.__options__.name(undefined!);\n    }\n    const localize = this.__options__?.localize ?? localizer.localize;\n    if (typeof localize === 'function') {\n      return localize(this.__options__?.name);\n    }\n    return this.__options__?.name;\n  }\n\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV) {\n    return this.__items__.label(keyOrValue);\n  }\n\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(value?: IV) {\n    return this.__items__.key(value);\n  }\n\n  raw(): T;\n  raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(\n    keyOrValue: IK\n  ): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;\n  raw<IK extends EnumValue>(value?: IK | unknown): T | T[K] | T[FindEnumKeyByValue<T, IK>] | undefined {\n    if (value != null) {\n      return this.__items__.raw(value as keyof T | EnumValue) as T[K];\n    } else {\n      return this.__items__.raw();\n    }\n  }\n\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V> {\n    return this.__items__.has(keyOrValue);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  findBy(...rest: Parameters<EnumItemsArray<T, K, V, P>['findBy']>): any {\n    return this.__items__.findBy(...rest);\n  }\n\n  toList(): ListItem<V, 'value', 'label'>[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n  >[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config?: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ):\n    | ListItem<V, 'value', 'label'>[]\n    | ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n      >[] {\n    return this.__items__.toList(config as ToListConfig<T, FOV, FOL, K, V, never, P>);\n  }\n\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config?: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P> {\n    return this.__items__.toMap(config as ToMapConfig<T, KS, VS, K, V, P>);\n  }\n\n  get valueType() {\n    return this.__items__.valueType;\n  }\n  get keyType() {\n    return this.__items__.keyType;\n  }\n  get rawType() {\n    return this.__items__.rawType;\n  }\n}\n","import type { EnumExtension } from 'enum-plus/extension';\nimport { EnumCollectionClass, EnumExtensionClass } from './enum-collection';\nimport type { EnumItemClass, EnumItemOptions } from './enum-item';\nimport type { IEnumItems, InheritableEnumItems } from './enum-items';\nimport { internalConfig, localizer } from './global-config';\nimport type {\n  ArrayToMap,\n  EnumInit,\n  EnumItemLabel,\n  EnumKey,\n  EnumValue,\n  IsAny,\n  LocalizeInterface,\n  ValueTypeFromSingleInit,\n} from './types';\nimport type { ENUM_OPTIONS, ITEMS, KEYS, LABELS, META, NAMED, VALUES } from './utils';\nimport { IS_ENUM } from './utils';\n\n/**\n * - **EN:** Create an enum collection\n * - **CN:** 创建一个枚举集合\n */\nexport const Enum = (<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const P = any,\n  OP extends EnumInitOptions<T, K, V, P> = EnumInitOptions<T, K, V, P>,\n>(\n  init: T | T[],\n  options?: OP\n): IEnum<T, K, V, P, OP> & NativeEnumMembers<T, K, V> => {\n  if (Array.isArray(init)) {\n    const initMap = getInitMapFromArray<T, K, V, P>(init, options);\n    return new EnumCollectionClass<T, K, V, P>(initMap, options) as unknown as NativeEnumMembers<T, K, V> &\n      IEnum<T, K, V, P, OP>;\n  } else {\n    return new EnumCollectionClass<T, K, V, P>(init, options) as unknown as NativeEnumMembers<T, K, V> &\n      IEnum<T, K, V, P, OP>;\n  }\n}) as EnumInterface;\n\n/*\n * Get or set the global localization function.\n * Use defineProperty here to prevent circular dependencies.\n */\n// Enum.config = {};\nObject.defineProperty(Enum, 'config', {\n  get: function () {\n    return internalConfig;\n  },\n  enumerable: true,\n  configurable: false,\n});\nObject.defineProperty(Enum, 'localize', {\n  get: function () {\n    return localizer.localize;\n  },\n  set: function (localize: LocalizeInterface) {\n    localizer.localize = localize;\n  },\n  enumerable: true,\n  configurable: false,\n});\n\nEnum.extends = function (obj: Record<string, unknown> | undefined) {\n  if (obj !== undefined && Object.prototype.toString.call(obj) !== '[object Object]') {\n    throw new Error('The extension of Enum must be an object');\n  }\n  Object.defineProperties(EnumExtensionClass.prototype, Object.getOwnPropertyDescriptors(obj));\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nEnum.install = <T extends PluginFunc<any>>(plugin: T, options?: Parameters<T>[0]) => {\n  plugin(options, Enum);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nEnum.isEnum = (value: unknown): value is IEnum<any, any, any, any> & NativeEnumMembers<any, any, any> => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return Boolean(value && typeof value === 'object' && (value as any)[IS_ENUM] === true);\n};\nObject.defineProperty(Enum, Symbol.hasInstance, {\n  value: function (instance: unknown) {\n    return Enum.isEnum(instance);\n  },\n  writable: false,\n  enumerable: false,\n  configurable: true,\n});\n\nfunction getInitMapFromArray<\n  const T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const P = any,\n>(init: T[], options?: ArrayBasedEnumInitOptions<T, K, V, P>) {\n  const { getValue = 'value' as keyof T, getLabel = 'label' as keyof T, getKey = 'key' as keyof T } = options ?? {};\n  return init.reduce((acc, item) => {\n    const value = typeof getValue === 'function' ? getValue(item) : (item[getValue] as V);\n    const label = typeof getLabel === 'function' ? getLabel(item) : item[getLabel];\n    let key: K | undefined = undefined;\n    if (getKey) {\n      key = typeof getKey === 'function' ? (getKey(item) as K) : (item[getKey] as K);\n    }\n    acc[(key ?? value) as unknown as K] = {\n      ...item,\n      label: label || (key ?? '') || (value != null ? value.toString() : value),\n      value,\n    } as unknown as T[K];\n    return acc;\n  }, {} as T);\n}\n\nexport interface EnumInterface {\n  new (): never;\n  /**\n   * - **EN:** Generate an enum collection, the enum value supports `number` and `string` types. Enum\n   *   names support localization schemes.\n   * - **CN:** 生成一个枚举集合，枚举值支持`number`和`string`类型，枚举名称支持本地化方案\n   *\n   * @example\n   *   const Week = Enum({\n   *     Sunday: { value: 0, label: 'Sunday' },\n   *     Monday: { value: 1, label: 'Monday' },\n   *   });\n   *\n   * @template T The type of enum initialization | 枚举初始化的类型\n   * @template K The type of enum keys | 枚举键的类型\n   * @template V The type of enum values | 枚举值的类型\n   *\n   * @param raw the raw initialization object for the enum collection | 枚举集合的原始初始化对象\n   * @param options the options for generating the enum collection | 生成枚举集合的选项\n   *\n   * @returns Enum collection | 枚举集合\n   */\n  // eslint-disable-next-line @typescript-eslint/prefer-function-type\n  <\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n    OP extends EnumInitOptions<T, K, V, P> = EnumInitOptions<T, K, V, P>,\n  >(\n    raw: T,\n    options?: EnumInitOptions<T, K, V, P>\n  ): IEnum<T, K, V, P, OP> & NativeEnumMembers<T, K, V>;\n\n  /**\n   * - **EN:** Generate an enum based on an array\n   * - **CN:** 基于数组生成枚举\n   *\n   * @example\n   *   const Week = Enum([\n   *     { value: 0, label: 'Sunday', key: 'Sun' },\n   *     { value: 1, label: 'Monday', key: 'Mon' },\n   *   ]);\n   *\n   * @template A The type of the initialization object array | 初始化对象数组的类型\n   * @template K The type of enum keys | 枚举键的类型\n   * @template V The type of enum values | 枚举值的类型\n   *\n   * @param raw The initialization object array for the enum collection | 初始化对象数组\n   * @param options The options for generating the enum collection | 生成枚举集合的选项\n   *\n   * @returns Enum collection | 枚举集合\n   */\n  <\n    const A extends Record<string, unknown>[] | readonly Record<string, unknown>[],\n    K extends EnumKey<ArrayToMap<A>> = EnumKey<ArrayToMap<A>>,\n    // @ts-expect-error: because no constraint on items of A, so ValueTypeFromSingleInit<ArrayToMap<A>[K], K> does not satisfy EnumValue\n    V extends EnumValue = ValueTypeFromSingleInit<ArrayToMap<A>[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n    // @ts-expect-error: because no constraint on items of A, so ArrayToMap<A> does not satisfy EnumInit<K, V>\n    OP extends ArrayBasedEnumInitOptions<A[number], K, V, P> = ArrayBasedEnumInitOptions<A[number], K, V, P>,\n  >(\n    init: A,\n    options?: OP\n    // @ts-expect-error: because no constraint on items of A, so ArrayToMap<A> does not satisfy EnumInit<K, V>\n  ): IEnum<ArrayToMap<A>, K, V, OP> & NativeEnumMembers<A, K, V>;\n\n  /**\n   * - **EN:** Global configuration for Enum\n   * - **CN:** 枚举的全局配置\n   */\n  config: {\n    /**\n     * - **EN:** Allow setting a label prefix for enum items, simplifying or even omitting the label\n     *   definition of enum items. This option is only needed when internationalization is enabled.\n     *   The prefix is set through `options.labelPrefix` when creating the Enum, which can be a\n     *   string or an object.\n     *\n     *   - `true` - Enable automatic concatenation of enum item localeKey in `options.labelPrefix` +\n     *       `label` format. `labelPrefix` only supports string in this case.\n     *   - `Function` - Dynamically generate the localeKey for enum items. `labelPrefix` supports any\n     *       type in this case.\n     *   - `false` - Disable automatic label generation, completely relying on the `label` field defined\n     *       in the enum item.\n     * - **CN:** 允许为枚举项设置label前缀，简化甚至可以省略枚举项的label定义，只有当开启国际化时才需要此选项。创建Enum时通过 `options.labelPrefix`\n     *   设置前缀，可以是字符串，也可以是一个对象。\n     *\n     *   - `true` - 启用自动拼接，`options.labelPrefix` + `label` 自动拼接生成标签，这种情况下 `labelPrefix` 只支持字符串形式\n     *   - `Function` - 动态生成枚举项localeKey，这种情况下 `labelPrefix` 支持任意类型\n     *   - `false` - 禁用自动生成标签，完全依赖枚举项中定义的 `label` 字段\n     */\n    autoLabel?:\n      | boolean\n      | ((options: {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          item: Omit<EnumItemClass<any, string, any, any>, 'label'>;\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          labelPrefix: any;\n        }) => string);\n  };\n\n  /**\n   * - **EN:** Convert resource key to localized text\n   *\n   * > Depending on different environments or technology frameworks, the return value may be of a type\n   * > other than a string, such as a component to support dynamic language switching, and the `label`\n   * > of the enum item will change accordingly.\n   *\n   * - **CN:** 把资源键值转化为本地化文本。\n   *\n   * > 根据不同的环境或技术框架，返回值可能是字符串以外类型，例如可能是一个组件以支持动态语言切换，而枚举项的`label`也会随之变化。\n   */\n  localize: LocalizeInterface | undefined;\n\n  /**\n   * - **EN:** Check if the value is an Enum collection\n   * - **CN:** 检查值是否是枚举集合的实例\n   *\n   * @param value -\n   *\n   *   - **EN:** Check if the value is an instance of the Enum collection\n   *   - **CN:** 检查值是否是枚举集合的实例\n   *\n   * @returns `true` if the value is an Enum collection, otherwise `false` |\n   *   如果值是枚举集合，则返回`true`，否则返回`false`\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isEnum(value: unknown): value is IEnum<any, any, any, any, any> & NativeEnumMembers<any, any, any>;\n  /**\n   * - **EN:** Determines if a value is an instance of the Enum collection\n   * - **CN:** 确定一个值是否是枚举集合的实例\n   *\n   * @param value The value to check | 要检查的值\n   *\n   * @returns `true` if the value is an Enum collection, otherwise `false` |\n   *   如果值是枚举集合，则返回`true`，否则返回`false`\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [Symbol.hasInstance](value: unknown): value is IEnum<any, any, any>;\n  /**\n   * - **EN:** Add global extension methods to the enum, and all enum instances will have these new\n   *   extension methods\n   * - **CN:** 为枚举增加全局扩展方法，所有枚举实例都会具有这些新扩展方法\n   *\n   * @param obj Extension content, must be an object | 扩展内容，必须是一个对象\n   */\n  extends: (\n    obj: Record<string, (this: ReturnType<EnumInterface>, ...args: any[]) => unknown> | Record<string, unknown>\n  ) => void;\n  /**\n   * - **EN:** Install a plugin that enhances the functionality of the Enum class by adding new\n   *   methods or properties.\n   * - **CN:** 安装一个插件，通过添加新的方法或属性来增强Enum类的功能\n   *\n   * @param plugin The plugin to install | 要安装的插件\n   * @param options The options for the plugin | 插件的选项\n   */\n  install: <T = unknown>(plugin: PluginFunc<T>, options?: T) => void;\n}\n\n/**\n * - **EN:** A generic enum type that can be used to represent any enum collection\n * - **CN:** 一个通用枚举类型，可以用来表示任何枚举集合\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyEnum = IEnum<any>;\n// @ts-expect-error: because T does not satisfy EnumInit<K, V>\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GenericAnyEnum<T extends EnumInit<keyof any, EnumValue>> = IEnum<T> &\n  // @ts-expect-error: because T does not satisfy EnumInit<K, V>\n  NativeEnumMembers<T>;\n\n/**\n * - **EN:** Represents an enumeration collection, which includes all the items in the enumeration and\n *   provides methods to access them.\n * - **CN:** 表示一个枚举集合，包含了枚举中的所有项，并提供访问它们的方法。\n */\nexport interface IEnum<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n  OP extends EnumInitOptions<T, K, V, P> = EnumInitOptions<T, K, V, P>,\n> extends InheritableEnumItems<T, K, V, P>,\n    EnumExtension<T, K, V> {\n  /**\n   * - **EN:** A boolean value indicates that this is an Enum.\n   * - **CN:** 布尔值，表示这是一个枚举类\n   */\n  // this flag exists but is removed from interface, as it's replaced with isEnum method\n  // [IS_ENUM]: true;\n  /** - */\n  [ENUM_OPTIONS]?: OP;\n  /**\n   * - **EN:** Alias for the `items` array, when any enum key conflicts with `items`, you can access\n   *   all enum items through this alias\n   * - **CN:** `items`数组的别名，当任何枚举的key与`items`冲突时，可以通过此别名访问所有枚举项\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [ITEMS]: IsAny<T> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      EnumItemClass<any, string, EnumValue, P>[]\n    : T extends { items: unknown }\n      ? EnumItemClass<T[K], K, V, P>[] & IEnumItems<T, K, V, P>\n      : never;\n  /**\n   * - **EN:** All items in the enumeration as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 所有枚举项的数组\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly items: IsAny<T> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      EnumItemClass<any, string, EnumValue, P>[] & IEnumItems<any, string, EnumValue, P>\n    : T extends { items: unknown }\n      ? ValueTypeFromSingleInit<T['items'], 'items', T[K] extends number | undefined ? number : 'items'>\n      : EnumItemClass<T[K], K, V, P>[] & IEnumItems<T, K, V, P>;\n  /**\n   * - **EN:** Alias for the `keys` array, when any enum key conflicts with `keys`, you can access all\n   *   enum keys through this alias\n   * - **CN:** `keys`数组的别名，当任何枚举的key与`keys`冲突时，可以通过此别名访问所有枚举项的keys\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [KEYS]: IsAny<T> extends true ? string[] : T extends { keys: unknown } ? K[] : never;\n  /**\n   * - **EN:** Get all keys of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部keys列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly keys: IsAny<T> extends true\n    ? string[]\n    : T extends { keys: unknown }\n      ? ValueTypeFromSingleInit<T['keys'], 'keys', T[K] extends number | undefined ? number : 'keys'>\n      : K[];\n  /**\n   * - **EN:** Alias for the `values` array, when any enum key conflicts with `values`, you can access\n   *   all enum values through this alias\n   * - **CN:** `values`数组的别名，当任何枚举的key与`values`冲突时，可以通过此别名访问所有枚举项的values\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [VALUES]: IsAny<T> extends true ? EnumValue[] : T extends { values: unknown } ? V[] : never;\n  /**\n   * - **EN:** Get all values of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部values列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly values: IsAny<T> extends true\n    ? EnumValue[]\n    : T extends { values: unknown }\n      ? ValueTypeFromSingleInit<T['values'], 'values', T[K] extends number | undefined ? number : 'values'>\n      : V[];\n  /**\n   * - **EN:** Alias for the `labels` array, when any enum key conflicts with `labels`, you can access\n   *   all enum labels through this alias\n   * - **CN:** `labels`数组的别名，当任何枚举的key与`labels`冲突时，可以通过此别名访问所有枚举项的labels\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [LABELS]: IsAny<T> extends true ? string[] : T extends { labels: unknown } ? string[] : never;\n  /**\n   * - **EN:** Get all labels of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部labels列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly labels: IsAny<T> extends true\n    ? string[]\n    : T extends { labels: unknown }\n      ? ValueTypeFromSingleInit<T['labels'], 'labels', T[K] extends number | undefined ? number : 'labels'>\n      : string[];\n  /**\n   * - **EN:** Alias for the `named` array, when any enum key conflicts with `named`, you can access\n   *   all enum names through this alias\n   * - **CN:** `named`数组的别名，当任何枚举的key与`named`冲突时，可以通过此别名访问所有枚举项的names\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [NAMED]: IsAny<T> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Record<string, EnumItemClass<any, string, EnumValue, P>>\n    : T extends { named: unknown }\n      ? IEnumItems<T, K, V, P>['named']\n      : never;\n  /**\n   * - **EN:** Get all names of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly named: IsAny<T> extends true\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Record<string, EnumItemClass<any, string, EnumValue, P>>\n    : T extends { named: unknown }\n      ? ValueTypeFromSingleInit<T['named'], 'named', T[K] extends number | undefined ? number : 'named'>\n      : IEnumItems<T, K, V, P>['named'];\n  /**\n   * - **EN:** Alias for the `meta` array, when any enum key conflicts with `meta`, you can access all\n   *   enum meta information through this alias\n   * - **CN:** `meta`数组的别名，当任何枚举的key与`meta`冲突时，可以通过此别名访问所有枚举项的meta信息\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly [META]: IsAny<T> extends true\n    ? Record<string, unknown[]>\n    : T extends { meta: unknown }\n      ? IEnumItems<T, K, V, P>['meta']\n      : never;\n  /**\n   * - **EN:** Get all meta information of the enumeration items as an array\n   *\n   * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any\n   * > modification methods\n   *\n   * - **CN:** 获取枚举项的全部meta信息列表\n   *\n   * > 仅支持 `ReadonlyArray<T>` 中的只读方法，不支持push、pop等任何修改的方法\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly meta: IsAny<T> extends true\n    ? Record<string, unknown[]>\n    : T extends { meta: unknown }\n      ? ValueTypeFromSingleInit<T['meta'], 'meta', T[K] extends number | undefined ? number : 'meta'>\n      : IEnumItems<T, K, V, P>['meta'];\n}\n\nexport type NativeEnumMembers<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n> = {\n  // Add enum item values, just like native enums\n  [key in K]: ValueTypeFromSingleInit<T[key], key, T[K] extends number | undefined ? number : key>;\n};\n\n/**\n * - **EN:** Enum initialization options\n * - **CN:** 枚举初始化选项\n */\nexport interface EnumInitOptions<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> extends EnumItemOptions<T[K], K, V, P> {\n  /**\n   * - **EN:** Set the display name of the enum collection, supports string or localized resource key\n   * - **CN:** 设置枚举集合的显示名称，支持字符串或本地化资源的键名\n   */\n  name?: EnumItemLabel;\n}\n\nexport interface ArrayBasedEnumInitOptions<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  P = any,\n> extends EnumInitOptions<T, K, V, P> {\n  /**\n   * - **EN:** The name of the field in the enumeration item that stores the value, or the function to\n   *   get the key value, default is `value`. This option is only effective when initializing the\n   *   enum through an array.\n   * - **CN:** 枚举项的value字段名，或者获取key值的函数，默认为 `value`。此选项只有在通过数组初始化枚举时才有效。\n   */\n  getValue?: keyof T | ((item: T) => EnumValue);\n  /**\n   * - **EN:** The name of the field in the enumeration item that stores the label, or the function to\n   *   get the key value, default is `label`. This option is only effective when initializing the\n   *   enum through an array.\n   * - **CN:** 枚举项的label字段名，或者获取key值的函数，默认为 `label`。此选项只有在通过数组初始化枚举时才有效。\n   */\n  getLabel?: keyof T | ((item: T) => string);\n  /**\n   * - **EN:** The name of the field in the enumeration item that stores the key, or the function to\n   *   get the key value, default is `key`. This option is only effective when initializing the enum\n   *   through an array.\n   * - **CN:** 枚举项的key字段名，或者获取key值的函数，默认为 `key`。此选项只有在通过数组初始化枚举时才有效。\n   */\n  getKey?: keyof T | ((item: T) => string);\n}\n\n/**\n * - **EN:** Represent the Enum plugin that enhances the functionality of the global Enum by adding\n *   new methods or properties.\n * - **CN:** 表示增强Enum类功能的插件，通过添加新方法或属性\n *\n * @param options The options for the plugin | 插件的选项\n * @param Enum The Enum global method | Enum全局方法\n */\nexport type PluginFunc<T = unknown> = (option: T | undefined, Enum: EnumInterface) => void;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","version","ITEMS","for","KEYS","VALUES","LABELS","ENUM_OPTIONS","META","NAMED","IS_ENUM_ITEM","IS_ENUM","IS_ENUM_ITEMS","defaultLocalize","content","localizer","localize","internalConfig","autoLabel","EnumItemClass","_options","_label","_localize","constructor","label","raw","options","this","writable","configurable","defineProperties","labelPrefix","localeKey","item","undefined","freeze","toPrimitive","hint","valueOf","toString","toLocaleString","EnumItemsArray","Array","__raw__","labels","named","meta","_runtimeError","super","keys","filter","k","test","parseKeys","parsed","map","init","Error","JSON","stringify","some","parseEnumItem","items","forEach","index","push","itemRaw","metaKey","metaValue","values","from","name","hasInstance","instance","i","keyOrValue","find","itemByValue","has","findBy","field","toList","config","valueField","labelField","extra","valueFieldName","labelFieldName","extraData","toMap","reduce","prev","cur","keySelector","valueSelector","valueType","keyType","rawType","EnumExtensionClass","EnumCollectionClass","__options__","__items__","includes","rest","Enum","isArray","initMap","getValue","getLabel","getKey","acc","getInitMapFromArray","set","extends","getOwnPropertyDescriptors","install","plugin","isEnum","Boolean"],"sourceRoot":""}