/**
 * enum-plus (ES2020 compatible})
 * A drop-in replacement for native enum. Like native enum but much better!
 *
 * @version: 3.1.6
 * @author: 李凤宝(Leo) <shijistar@gmail.com>
 * @link https://github.com/shijistar/enum-plus
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.EnumPlus=t():e.EnumPlus=t()}(self,(function(){return function(){"use strict";var e={d:function(t,r){for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r:function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ENUM_OPTIONS:function(){return u},Enum:function(){return g},IS_ENUM:function(){return f},IS_ENUM_ITEM:function(){return c},IS_ENUM_ITEMS:function(){return b},ITEMS:function(){return n},KEYS:function(){return o},LABELS:function(){return l},META:function(){return a},NAMED:function(){return s},VALUES:function(){return i},defaultLocalize:function(){return _},version:function(){return r}});const r="3.1.6",n=Symbol.for("[items]"),o=Symbol.for("[keys]"),i=Symbol.for("[values]"),l=Symbol.for("[labels]"),u=(Symbol.for("[raw]"),Symbol.for("[EnumOptions]")),a=Symbol.for("[meta]"),s=Symbol.for("[named]"),c=Symbol.for("[IsEnumItem]"),f=Symbol.for("[IsEnum]"),b=Symbol.for("[IsEnumItems]"),_=e=>e,y={localize:_},m={autoLabel:!0};class h{_options;_label;_localize;constructor(e,t,r,n,o){this.key=e,this.value=t,this.label=r,this.raw=n,Object.defineProperty(this,"_label",{value:r,writable:!1,enumerable:!1,configurable:!1}),Object.defineProperties(this,{value:{value:t,writable:!1,enumerable:!0,configurable:!1},label:{get:function(){const e=this._options?.labelPrefix,t=this._options?.autoLabel??m.autoLabel;let r=this._label;return"function"==typeof r?r(this):(t&&null!=e&&(r="function"==typeof t?t({item:this,labelPrefix:e}):`${e}${this._label}`),this._localize(r)??r)},enumerable:!0,configurable:!1},key:{value:e,writable:!1,enumerable:!0,configurable:!1},raw:{value:n,writable:!1,enumerable:!0,configurable:!1}}),Object.defineProperty(this,"_options",{value:o,writable:!1,enumerable:!1,configurable:!1}),this._localize=void 0,Object.defineProperty(this,"_localize",{value:function(e){const t=this._options?.localize??y.localize;return"function"==typeof t?t(e):e},writable:!1,enumerable:!1,configurable:!1}),Object.freeze(this)}value;label;key;raw;get[c](){return!0}[Symbol.toPrimitive](e){return"number"===e?this.valueOf():"string"===e?this.toString():this.valueOf()}toString(){return this.label}toLocaleString(){return this.toString()}valueOf(){return this.value}}class p extends Array{__raw__;get[b](){return!0}[o];[i];labels;named;meta;_runtimeError;constructor(e,t){super(),Object.defineProperty(this,"__raw__",{value:e,enumerable:!1,writable:!1,configurable:!1});const r=function(e){return Object.keys(e).filter((t=>!(/^-?\d+$/.test(t)&&t===`${e[e[t]]??""}`)))}(e),n=r.map((t=>function(e,t){let r,n;if(null!=e)if("number"==typeof e||"string"==typeof e||"symbol"==typeof e)r=e,n=t;else{if("object"!=typeof e)throw new Error(`Invalid enum item: ${JSON.stringify(e)}`);"[object Object]"===Object.prototype.toString.call(e)?"value"in e&&Object.keys(e).some((e=>"value"===e))?(r=e.value??t,n="label"in e&&Object.keys(e).some((e=>"label"===e))?e.label:t):"label"in e&&Object.keys(e).some((e=>"label"===e))?(r=t,n=e.label??t):(r=t,n=t):(r=e,n=t)}else r=t,n=t;return{value:r,label:n}}(e[t],t)));this[o]=r,Object.freeze(r);const l=[],u={};this.meta=u;const a={};this.named=a,r.forEach(((r,o)=>{const{value:i,label:s}=n[o],c=new h(r,i,s,e[r],t);l.push(c),this.push(c),a[r]=c;const f=e[r];f&&"object"==typeof f&&Object.keys(f).forEach((e=>{const t=e;if("key"!==t&&"value"!==t&&"label"!==t){null==u[t]&&(u[t]=[]);const e=f[t];null!=e&&u[t].push(e)}}))})),Object.keys(u).forEach((e=>{Object.freeze(u[e])}));const s=n.map((e=>e.value));this[i]=s,Object.freeze(s),Object.defineProperty(this,"labels",{get:function(){return Array.from(this).map((e=>e.label))},enumerable:!0,configurable:!1}),this._runtimeError=void 0,Object.defineProperty(this,"_runtimeError",{value:function(e){return`The ${e} property of the enumeration is only allowed to be used to declare the ts type, and cannot be accessed at runtime! Please use the typeof operator in the ts type, for example: typeof Week.${e}`},writable:!1,enumerable:!1,configurable:!1})}[Symbol.hasInstance](e){return this.some((t=>e==t.value||e===t.key))}label(e){return(this.find((t=>t.value===e))??this.find((t=>t.key===e)))?.label}key(e){return this.find((t=>t.value===e))?.key}raw(e){if(null==e)return this.__raw__;{if(Object.keys(this.__raw__).some((t=>t===e)))return this.__raw__[e];const t=this.find((t=>t.value===e));return t?t.raw:void 0}}has(e){return this.some((t=>t.value===e||t.key===e))}findBy(e,t){return this.find((r=>"key"===e||"value"===e?r[e]===t:"label"===e?r.raw?.label===t||r.label===t:r.raw?.[e]===t))}toList(e){const{valueField:t="value",labelField:r="label",extra:n}=e??{};return Array.from(this).map((e=>{const o="function"==typeof t?t(e):t,i="function"==typeof r?r(e):r,l=n?n(e):{};return{[o]:e.value,[i]:e.label,...l}}))}toMap(e){if(!e)return this.reduce(((e,t)=>(e[t.value]=t.label,e)),{});const{keySelector:t="value",valueSelector:r="label"}=e;return this.reduce(((e,n)=>{let o,i;return o="function"==typeof t?t(n):n[t],i="function"==typeof r?r(n):n[r],e[o]=i,e}),{})}get valueType(){throw new Error(this._runtimeError("valueType"))}get keyType(){throw new Error(this._runtimeError("keyType"))}get rawType(){throw new Error(this._runtimeError("rawType"))}}class d{}class v extends d{__options__;__items__;constructor(e={},t){super(),Object.defineProperty(this,"__options__",{value:t,writable:!1,enumerable:!1,configurable:!1});const r=Object.keys(e),u=new p(e,t);Object.freeze(u),this[r.includes("items")?n:"items"]=u,Object.defineProperty(this,"__items__",{value:u,writable:!1,enumerable:!1,configurable:!1}),this[r.includes("keys")?o:"keys"]=u[o],this[r.includes("values")?i:"values"]=u[i],this[r.includes("named")?s:"named"]=u.named,this[r.includes("meta")?a:"meta"]=u.meta,u.forEach((e=>{this[e.key]=e.value})),Object.defineProperty(this,r.includes("labels")?l:"labels",{enumerable:!0,configurable:!1,get:function(){return this.__items__.labels}}),Object.freeze(this)}get[f](){return!0}get[u](){return this.__options__}[Symbol.hasInstance](e){return e instanceof this.__items__}get name(){if("function"==typeof this.__options__?.name)return this.__options__.name(void 0);const e=this.__options__?.localize??y.localize;return"function"==typeof e?e(this.__options__?.name):this.__options__?.name}label(e){return this.__items__.label(e)}key(e){return this.__items__.key(e)}raw(e){return null!=e?this.__items__.raw(e):this.__items__.raw()}has(e){return this.__items__.has(e)}findBy(...e){return this.__items__.findBy(...e)}toList(e){return this.__items__.toList(e)}toMap(e){return this.__items__.toMap(e)}get valueType(){return this.__items__.valueType}get keyType(){return this.__items__.keyType}get rawType(){return this.__items__.rawType}}const g=(e,t)=>{if(Array.isArray(e)){const r=function(e,t){const{getValue:r="value",getLabel:n="label",getKey:o="key"}=t??{};return e.reduce(((e,t)=>{const i="function"==typeof r?r(t):t[r],l="function"==typeof n?n(t):t[n];let u;return o&&(u="function"==typeof o?o(t):t[o]),e[u??i]={...t,label:l||(u??"")||(null!=i?i.toString():i),value:i},e}),{})}(e,t);return new v(r,t)}return new v(e,t)};return Object.defineProperty(g,"config",{get:function(){return m},enumerable:!0,configurable:!1}),Object.defineProperty(g,"localize",{get:function(){return y.localize},set:function(e){y.localize=e},enumerable:!0,configurable:!1}),g.extends=function(e){if(void 0!==e&&"[object Object]"!==Object.prototype.toString.call(e))throw new Error("The extension of Enum must be an object");Object.defineProperties(d.prototype,Object.getOwnPropertyDescriptors(e))},g.install=(e,t)=>{e(t,g)},g.isEnum=e=>Boolean(e&&"object"==typeof e&&!0===e[f]),Object.defineProperty(g,Symbol.hasInstance,{value:function(e){return g.isEnum(e)},writable:!1,enumerable:!1,configurable:!0}),t}()}));
//# sourceMappingURL=enum-plus.min.js.map