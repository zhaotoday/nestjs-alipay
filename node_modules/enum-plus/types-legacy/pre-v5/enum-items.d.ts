import type { EnumItemOptions } from './enum-item';
import { EnumItemClass } from './enum-item';
import type { EnumInit, EnumKey, EnumValue, ExactEqual, FindEnumKeyByValue, FindKeyByMeta, FindLabelByValue, FindValueByKey, FindValueByMeta, ListItem, PrimitiveOf, StandardEnumItemInit, ValueTypeFromSingleInit } from './types';
import { IS_ENUM_ITEMS, KEYS, VALUES } from './utils';
/**
 * Enum items array, mostly are simple wrappers for EnumCollectionClass
 *
 * @template T Type of the initialization data of the enum collection
 *
 * @class EnumItemsArray
 *
 * @extends {EnumItemClass<T, K, V>[]}
 *
 * @implements {IEnumItems<T, K, V>}
 */
export declare class EnumItemsArray<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, P = any> extends Array<EnumItemClass<T[K], K, V, P>> implements IEnumItems<T, K, V, P> {
    private __raw__;
    /**
     * - **EN:** A boolean value indicates that this is an enum items array.
     * - **CN:** å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæšä¸¾é¡¹æ•°ç»„
     */
    get [IS_ENUM_ITEMS](): true;
    readonly [KEYS]: K[];
    readonly [VALUES]: V[];
    readonly labels: string[];
    readonly named: {
        [key in keyof T]: EnumItemClass<T[key], key, ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>, P>;
    };
    readonly meta: IEnumItems<T, K, V, P>['meta'];
    private _runtimeError;
    /**
     * Instantiate an enum items array
     *
     * @memberof EnumItemsArray
     *
     * @param {T} raw Original initialization data object
     * @param {EnumItemOptions<T[K], K, V, P> | undefined} options Enum item options
     */
    constructor(raw: T, options: EnumItemOptions<T[K], K, V, P> | undefined);
    [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V>;
    label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV): (undefined extends KV ? undefined : never) | (KV extends undefined ? undefined : NonNullable<KV> extends K ? T[NonNullable<KV>] extends {
        label: unknown;
    } ? T[NonNullable<KV>]['label'] extends undefined ? NonNullable<KV> : string : NonNullable<KV> : NonNullable<KV> extends V ? FindLabelByValue<T, NonNullable<KV>> : PrimitiveOf<K> extends KV ? string | undefined : PrimitiveOf<V> extends KV ? string | undefined : undefined);
    key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(value?: IV): (undefined extends IV ? undefined : never) | (IV extends undefined ? undefined : NonNullable<IV> extends V ? FindEnumKeyByValue<T, NonNullable<IV>> : PrimitiveOf<V> extends NonNullable<IV> ? K | undefined : undefined);
    raw(): T;
    raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(keyOrValue: IK): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;
    has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V>;
    findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, FV>(field: FK, value: FV): FK extends 'key' ? FV extends K ? EnumItemClass<T[FV], FV, FindValueByKey<T, FV>> : EnumItemClass<T[K], K, V, P> | undefined : FK extends 'value' ? FV extends V ? EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV> : EnumItemClass<T[K], K, V, P> | undefined : FK extends 'label' ? EnumItemClass<T[K], K, V, P> | undefined : FV extends T[keyof T][FK] ? EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>> : EnumItemClass<T[K], K, V, P> | undefined;
    toList(): ListItem<V, 'value', 'label'>[];
    toList<FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), R extends Record<string, unknown> = never>(config: ToListConfig<T, FOV, FOL, K, V, R, P>): ListItem<V, FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV, FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL, R>[];
    toMap(): MapResult<T, 'value', 'label', K, V, P>;
    toMap<KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any), VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any)>(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;
    /** Stub method, only for typing usages, not for runtime calling */
    get valueType(): V;
    /** Stub method, only for typing usages, not for runtime calling */
    get keyType(): K;
    /** Stub method, only for typing usages, not for runtime calling */
    get rawType(): T[K];
}
/**
 * - **EN:** Enum item collection interface, excluding members inherited from the array
 * - **CN:** æšä¸¾é¡¹é›†åˆæ¥å£ï¼Œä¸åŒ…å«ä»æ•°ç»„é›†æˆçš„æˆå‘˜
 *
 * @template T The type of enum initialization | æšä¸¾åˆå§‹åŒ–çš„ç±»å‹
 * @template K The type of enum keys | æšä¸¾é”®çš„ç±»å‹
 * @template V The type of enum values | æšä¸¾å€¼çš„ç±»å‹
 *
 * @interface IEnumItems
 */
export interface IEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, P = any> extends InheritableEnumItems<T, K, V, P> {
    /**
     * - **EN:** A boolean value indicates that this is an enum items array.
     * - **CN:** å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæšä¸¾é¡¹æ•°ç»„
     */
    [IS_ENUM_ITEMS]: true;
    /**
     * - **EN:** Get all keys of the enumeration items as an array
     *
     * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any
     * > modification methods
     *
     * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨keysåˆ—è¡¨
     *
     * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•
     */
    readonly [KEYS]: K[];
    /**
     * - **EN:** Get all values of the enumeration items as an array
     *
     * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any
     * > modification methods
     *
     * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨valuesåˆ—è¡¨
     *
     * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•
     */
    readonly [VALUES]: V[];
    /**
     * - **EN:** Get all labels of the enumeration items as an array
     *
     * > Only supports read-only methods in `ReadonlyArray<T>`, does not support push, pop, and any
     * > modification methods
     *
     * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨labelsåˆ—è¡¨
     *
     * > ä»…æ”¯æŒ `ReadonlyArray<T>` ä¸­çš„åªè¯»æ–¹æ³•ï¼Œä¸æ”¯æŒpushã€popç­‰ä»»ä½•ä¿®æ”¹çš„æ–¹æ³•
     */
    readonly labels: string[];
    /**
     * - **EN:** A mapping of enum keys to their corresponding enum item classes. This is useful for
     *   quick access to specific enum items.
     * - **CN:** æšä¸¾é”®åˆ°å…¶å¯¹åº”çš„æšä¸¾é¡¹ç±»çš„æ˜ å°„ï¼Œå¯¹äºå¿«é€Ÿè®¿é—®æšä¸¾é¡¹éå¸¸æœ‰ç”¨
     */
    named: {
        [key in keyof T]: EnumItemClass<T[key], key, ValueTypeFromSingleInit<T[key], key, T[key] extends number | undefined ? number : key>, P>;
    };
    /**
     * - **EN:** Get all custom meta fields of the enumeration items as an object, where the keys are
     *   the field names, and values are the raw values of each field
     * - **CN:** è·å–æšä¸¾é¡¹çš„å…¨éƒ¨è‡ªå®šä¹‰å…ƒå­—æ®µï¼Œè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­keyä¸ºå­—æ®µåï¼Œvalueä¸ºæ¯ä¸ªå­—æ®µçš„åŸå§‹å€¼æ•°ç»„
     */
    readonly meta: T extends object ? {
        [K in Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>]: T[keyof T][K][];
    } : {};
}
export interface InheritableEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, P = any> {
    /**
     * - **EN:** A method that determines if a constructor object recognizes an object as one of the
     *   constructorâ€™s instances. Called by the semantics of the `instanceof` operator.
     * - **CN:** ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºç¡®å®šæ„é€ å‡½æ•°å¯¹è±¡æ˜¯å¦å°†å¯¹è±¡è¯†åˆ«ä¸ºæ„é€ å‡½æ•°çš„å®ä¾‹ä¹‹ä¸€ã€‚ç”± `instanceof` è¿ç®—ç¬¦çš„è¯­ä¹‰è°ƒç”¨ã€‚
     */
    [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V>;
    /**
     * - **EN:** The enum collection name, supports localization.
     *
     * > Note that it usually returns a string, but if a custom `localize` function is set, the return
     * > value may vary depending on the implementation of the method.
     *
     * - **CN:** æšä¸¾é›†åˆæ˜¾ç¤ºåç§°ï¼Œæ”¯æŒæœ¬åœ°åŒ–ã€‚
     *
     * > æ³¨æ„ï¼Œé€šå¸¸æƒ…å†µä¸‹è¿”å›çš„æ˜¯å­—ç¬¦ä¸²ï¼Œä½†å¦‚æœè®¾ç½®äº†è‡ªå®šä¹‰çš„ `localize` å‡½æ•°ï¼Œåˆ™è¿”å›å€¼å¯èƒ½æœ‰æ‰€ä¸åŒï¼Œå–å†³äºæ–¹æ³•çš„å®ç°
     *
     * @returns {string | undefined} The localized name of the enum collection, or undefined if not
     *   set | æšä¸¾é›†åˆçš„æœ¬åœ°åŒ–åç§°ï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä¸º undefined
     */
    readonly name?: string;
    /**
     * - **EN:** Get the label (also known as display name) of the enumeration item, supports getting by
     *   value or key
     * - **CN:** è·å–æšä¸¾é¡¹çš„æ ‡ç­¾ï¼ˆäº¦ç§°æ˜¾ç¤ºåç§°ï¼‰ï¼Œæ”¯æŒé€šè¿‡æšä¸¾é¡¹çš„ value æˆ– key è·å–
     *
     * @param keyOrValue - The value or key of the enumeration item | æšä¸¾é¡¹çš„ value æˆ– key
     *
     * @returns The label of the enumeration item or the key if the label is not defined | æšä¸¾é¡¹çš„æ ‡ç­¾æˆ–
     *   keyï¼ˆå¦‚æœæ ‡ç­¾æœªå®šä¹‰ï¼‰
     */
    label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV): (undefined extends KV ? undefined : never) | (KV extends undefined ? undefined : NonNullable<KV> extends K ? T[NonNullable<KV>] extends {
        label: unknown;
    } ? T[NonNullable<KV>]['label'] extends undefined ? NonNullable<KV> : string : NonNullable<KV> : NonNullable<KV> extends V ? FindLabelByValue<T, NonNullable<KV>> : PrimitiveOf<K> extends KV ? string | undefined : PrimitiveOf<V> extends KV ? string | undefined : undefined);
    /**
     * - **EN:** Get the key of the enumeration item by its value
     * - **CN:** æ ¹æ®æšä¸¾é¡¹çš„ value è·å–å…¶ key
     *
     * @param value The value of the enumeration item | æšä¸¾é¡¹çš„ value
     *
     * @returns The key of the enumeration item, or undefined if not found | æšä¸¾é¡¹çš„ keyï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›
     *   undefined
     */
    key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(value: IV): (undefined extends IV ? undefined : never) | (IV extends undefined ? undefined : NonNullable<IV> extends V ? FindEnumKeyByValue<T, NonNullable<IV>> : PrimitiveOf<V> extends NonNullable<IV> ? K | undefined : undefined);
    /**
     * - **EN:** Get the enumeration item by key or value
     * - **CN:** è·å–æšä¸¾é›†åˆçš„åˆå§‹åŒ–å¯¹è±¡
     *
     * @returns {T} Enum collection initialization object | åˆå§‹åŒ–å¯¹è±¡é›†åˆ
     */
    raw(): T;
    /**
     * - **EN:** Get the original initialization object of a certain enumeration item. If custom fields
     *   are added to the enumeration item, you can use this method to get them.
     * - **CN:** è·å–æŸä¸ªæšä¸¾é¡¹çš„åŸå§‹åˆå§‹åŒ–å¯¹è±¡ã€‚å¦‚æœåœ¨æšä¸¾é¡¹ä¸Šå¢åŠ äº†è‡ªå®šä¹‰å­—æ®µçš„è¯ï¼Œå¯ä»¥ç”¨è¿™ç§æ–¹å¼è·å–åˆ°ã€‚
     *
     * @param keyOrValue Enum key or value | æšä¸¾keyæˆ–value
     *
     * @returns The original initialization object of the enumeration item, or undefined if not found
     *   | æšä¸¾é¡¹çš„åŸå§‹åˆå§‹åŒ–å¯¹è±¡ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› undefined
     */
    raw<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV): (undefined extends KV ? undefined : never) | (KV extends undefined ? undefined : NonNullable<KV> extends K ? T[NonNullable<KV>] : NonNullable<KV> extends V ? T[FindEnumKeyByValue<T, NonNullable<KV>>] : PrimitiveOf<K> extends KV ? T[K] | undefined : PrimitiveOf<V> extends KV ? T[K] | undefined : undefined);
    /**
     * - **EN:** Get the value corresponding to a certain enumeration item
     * - **CN:** åˆ¤æ–­æŸä¸ªæšä¸¾é¡¹æ˜¯å¦å­˜åœ¨
     *
     * @param keyOrValue Enum item key or value | æšä¸¾é¡¹çš„keyæˆ–value
     *
     * @returns {boolean} Whether the enumeration item exists | æšä¸¾é¡¹æ˜¯å¦å­˜åœ¨
     */
    has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V>;
    /**
     * **EN:** Find an enumeration item by key or value, or by custom meta fields
     *
     * **CN:** é€šè¿‡keyæˆ–valueæŸ¥æ‰¾æšä¸¾é¡¹ï¼Œæˆ–é€šè¿‡è‡ªå®šä¹‰å…ƒå­—æ®µæŸ¥æ‰¾
     *
     * @param field The field to search by | è¦æŸ¥æ‰¾çš„å­—æ®µ
     * @param value The value to search | è¦æŸ¥æ‰¾çš„å€¼
     *
     * @returns The found enumeration item or `undefined` if not found | æ‰¾åˆ°çš„æšä¸¾é¡¹ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å› `undefined`
     */
    findBy<FK extends 'key' | 'value' | 'label' | Exclude<keyof T[keyof T], 'key' | 'value' | 'label'>, FV>(field: FK, value: FV): FK extends 'key' ? FV extends K ? EnumItemClass<T[FV], FV, FindValueByKey<T, FV>> : EnumItemClass<T[K], K, V, P> | undefined : FK extends 'value' ? FV extends V ? EnumItemClass<T[FindEnumKeyByValue<T, FV>], FindEnumKeyByValue<T, FV>, FV> : EnumItemClass<T[K], K, V, P> | undefined : FK extends 'label' ? EnumItemClass<T[K], K, V, P> | undefined : FV extends T[keyof T][FK] ? EnumItemClass<T[FindKeyByMeta<T, FK, FV>], FindKeyByMeta<T, FK, FV>, FindValueByMeta<T, FK, FV>> : EnumItemClass<T[K], K, V, P> | undefined;
    /**
     * - **EN:** Generate an object array containing all enumeration items
     * - **CN:** ç”Ÿæˆä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹
     *
     * @example
     *   [
     *     { value: 0, label: 'Sunday' },
     *     { value: 1, label: 'Monday' },
     *   ];
     *
     * @returns An object array of all enumeration items | æ‰€æœ‰æšä¸¾é¡¹çš„å¯¹è±¡æ•°ç»„
     */
    toList(): ListItem<V, 'value', 'label'>[];
    /**
     * - **EN:** Generate an object array containing all enumeration items, with customizable value and
     *   label field names
     * - **CN:** ç”Ÿæˆä¸€ä¸ªå¯¹è±¡æ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œå¯è‡ªå®šä¹‰å€¼å’Œæ ‡ç­¾å­—æ®µå
     *
     * @example
     *   Week.toList({
     *     valueField: 'id',
     *     labelField: 'name',
     *   });
     *
     *   [
     *     { id: 0, name: 'Sunday' },
     *     { id: 1, name: 'Monday' },
     *   ];
     *
     * @param config Custom options, supports customizing value and label field names |
     *   è‡ªå®šä¹‰é€‰é¡¹ï¼Œæ”¯æŒè‡ªå®šä¹‰å€¼å’Œæ ‡ç­¾å­—æ®µå
     *
     * @returns An object array of all enumeration items in the specified value and label fields |
     *   æ‰€æœ‰æšä¸¾é¡¹çš„å¯¹è±¡æ•°ç»„ï¼ŒæŒ‰ç…§æŒ‡å®šçš„å€¼å’Œæ ‡ç­¾å­—æ®µæ ¼å¼
     */
    toList<FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), R extends Record<string, unknown> = never>(config: ToListConfig<T, FOV, FOL, K, V, R, P>): ListItem<V, FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV, FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL, R>[];
    /**
     * - **EN:** Generate a mapping object of all enum items, where the keys are the values of the enum
     *   and the values are the labels of the enum
     * - **CN:** ç”Ÿæˆä¸€ä¸ªæ˜ å°„å¯¹è±¡ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œkeyä¸ºæšä¸¾å€¼ï¼Œvalueä¸ºæšä¸¾æ ‡ç­¾
     *
     * @example
     *   {
     *     "0": "Sunday",
     *     "1": "Monday"
     *   }
     *
     * @returns A mapping object of all enum items | æ‰€æœ‰æšä¸¾é¡¹çš„æ˜ å°„å¯¹è±¡
     */
    toMap(): MapResult<T, 'value', 'label', K, V, P>;
    /**
     * - **EN:** Generate a mapping object of all enum items, with customizable key and value fields
     * - **CN:** ç”Ÿæˆä¸€ä¸ªæ˜ å°„å¯¹è±¡ï¼ŒåŒ…å«æ‰€æœ‰çš„æšä¸¾é¡¹ï¼Œå¯è‡ªå®šä¹‰é”®å’Œå€¼å­—æ®µ
     *
     * @example
     *   Week.toMap({ key: 'value', value: 'label' });
     *
     *   ({ '0': 'Sunday', '1': 'Monday' });
     *
     *   /// Allow custom function, and meta fields can be used
     *   Week.toMap({
     *     key: 'key',
     *     value: (item) => ({ id: item.value, name: item.label, foo: item.raw.foo }),
     *   });
     *
     *   ({
     *     Sunday: { id: 0, name: 'Sunday', foo: 'bar' },
     *     Monday: { id: 1, name: 'Monday', foo: 'b' },
     *   });
     *
     * @param config Custom options, supports customizing key and value fields | è‡ªå®šä¹‰é€‰é¡¹ï¼Œæ”¯æŒè‡ªå®šä¹‰é”®å’Œå€¼å­—æ®µ
     *
     * @returns A mapping object of all enum items in the specified key and value fields |
     *   æ‰€æœ‰æšä¸¾é¡¹çš„æ˜ å°„å¯¹è±¡ï¼ŒæŒ‰ç…§æŒ‡å®šçš„é”®å’Œå€¼å­—æ®µæ ¼å¼
     */
    toMap<FOK extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any), FOV extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any)>(config: ToMapConfig<T, FOK, FOV, K, V, P>): MapResult<T, FOK, FOV, K, V, P>;
    /**
     * - **EN:** The data type of all enumeration values
     *
     * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime
     *
     * - **CN:** æ‰€æœ‰æšä¸¾å€¼çš„æ•°æ®ç±»å‹
     *
     * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨
     *
     * @example
     *   // Declare the type of the variable | å£°æ˜å˜é‡çš„ç±»å‹
     *   const week: typeof Week.valueType = Week.Monday; // 0
     *
     *   // Declare type field | å£°æ˜ç±»å‹å­—æ®µ
     *   type Props = {
     *     week: typeof Week.valueType; // 0 | 1
     *   };
     */
    valueType: V;
    /**
     * - **EN:** The data type of all enumeration keys
     *
     * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime
     *
     * - **CN:** æ‰€æœ‰æšä¸¾keyçš„æ•°æ®ç±»å‹
     *
     * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨
     *
     * @example
     *   // Declare the type of the variable | å£°æ˜å˜é‡çš„ç±»å‹
     *   const weekName: typeof Week.keyType = 'Sunday'; // "Sunday" | "Monday"
     *
     *   // Declare type field | å£°æ˜ç±»å‹å­—æ®µ
     *   type Props = {
     *     weekName: typeof Week.keyType; // "Sunday" | "Monday"
     *   };
     */
    keyType: K;
    /**
     * - **EN:** The type of the original initialization object of the enumeration item. If custom
     *   fields are added to the enumeration item, you can use this method to get them.
     *
     * > ğŸ“£ Note: Can only be used as a type declaration, cannot be called at runtime
     *
     * - **CN:** æšä¸¾é¡¹åŸå§‹åˆå§‹åŒ–å¯¹è±¡çš„ç±»å‹ï¼Œå¦‚æœåœ¨æšä¸¾é¡¹ä¸Šå¢åŠ äº†è‡ªå®šä¹‰å­—æ®µçš„è¯ï¼Œå¯ä»¥ç”¨è¿™ç§æ–¹å¼è·å–åˆ°ã€‚
     *
     * > ğŸ“£ æ³¨æ„ï¼šä»…å¯ä½œä¸ºç±»å‹å£°æ˜ä½¿ç”¨ï¼Œä¸å¯åœ¨è¿è¡Œæ—¶è°ƒç”¨
     */
    rawType: T[K];
}
/** More options for the options method */
export interface ToListConfig<T extends EnumInit<K, V>, FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string), K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, R extends Record<string, unknown> = never, P = any> {
    /**
     * - **EN:** The name of the value field in the output object, or a function to get the field name,
     *   default is `value`
     * - **CN:** è¾“å‡ºå¯¹è±¡çš„valueå­—æ®µåï¼Œæˆ–è€…è·å–å­—æ®µåçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `value`
     */
    valueField?: FOV;
    /**
     * - **EN:** The name of the label field in the output object, or a function to get the field name,
     *   default is `label`
     * - **CN:** è¾“å‡ºå¯¹è±¡çš„labelå­—æ®µåï¼Œæˆ–è€…è·å–å­—æ®µåçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `label`
     */
    labelField?: FOL;
    /**
     * - **EN:** A function to add extra fields to each item in the output object
     * - **CN:** ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºä¸ºè¾“å‡ºå¯¹è±¡ä¸­çš„æ¯ä¸ªé¡¹æ·»åŠ é¢å¤–çš„å­—æ®µ
     */
    extra?: (item: EnumItemClass<T[K], K, V, P>) => R;
}
export interface ToMapConfig<T extends EnumInit<K, V>, KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any), VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any), K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, P = any> {
    /**
     * - **EN:** A field of `EnumItem` as the key of the output object, or a function to get the key of
     *   items, default is `key`
     * - **CN:** ä½œä¸ºè¾“å‡ºå¯¹è±¡keyçš„`EnumItem`å­—æ®µåï¼Œæˆ–è€…è·å–è¾“å‡ºå¯¹è±¡keyçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `key`
     */
    keySelector?: KS;
    /**
     * - **EN:** A field of `EnumItem` as the value of the output object, or a function to get the value
     *   of items, default is `value`
     * - **CN:** ä½œä¸ºè¾“å‡ºå¯¹è±¡valueçš„`EnumItem`å­—æ®µåï¼Œæˆ–è€…è·å–è¾“å‡ºå¯¹è±¡valueçš„å‡½æ•°ï¼Œé»˜è®¤ä¸º `value`
     */
    valueSelector?: VS;
}
export type MapResult<T extends EnumInit<K, V>, KS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol), VS extends EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => any), K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>, P = any> = {
    [key in ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
    EnumItemClass<T[K], K, V, P>['value'] & keyof any : KS extends EnumItemFields ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
    EnumItemClass<T[K], K, V, P>[KS] & keyof any : KS extends (item: any) => infer R ? R : never]: ExactEqual<VS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => unknown)> extends true ? ExactEqual<KS, EnumItemFields | ((item: EnumItemClass<T[K], K, V, P>) => string | symbol)> extends true ? FindLabelByValue<T, key> : EnumItemClass<T[K], K, V, P>['label'] : VS extends EnumItemFields ? EnumItemClass<T[K], K, V, P>[VS] : VS extends (item?: any) => infer R ? R : never;
};
export type EnumItemFields = Exclude<{
    [key in keyof EnumItemClass<StandardEnumItemInit<string>>]: EnumItemClass<StandardEnumItemInit<string>>[key] extends (...args: any[]) => unknown ? never : key;
}[keyof EnumItemClass<StandardEnumItemInit<string>>] & string, 'raw'>;
export declare function parseKeys<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(raw: EnumInit<K, V>): K[];
