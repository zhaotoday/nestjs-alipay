{"version":3,"names":["EnumItemsArray","localizer","ENUM_OPTIONS","IS_ENUM","ITEMS","KEYS","LABELS","META","NAMED","VALUES","EnumExtensionClass","EnumCollectionClass","__options__","__items__","constructor","init","options","Object","defineProperty","value","writable","enumerable","configurable","keys","items","freeze","includes","named","meta","forEach","item","key","get","labels","Symbol","hasInstance","instance","name","undefined","localize","label","keyOrValue","raw","has","findBy","rest","toList","config","toMap","valueType","keyType","rawType"],"sources":["../src/enum-collection.ts"],"sourcesContent":["import type { EnumExtension } from 'enum-plus/extension';\nimport type { EnumInitOptions } from './enum';\nimport type { EnumItemClass, EnumItemOptions } from './enum-item';\nimport type { EnumItemFields, InheritableEnumItems, MapResult, ToListConfig, ToMapConfig } from './enum-items';\nimport { EnumItemsArray } from './enum-items';\nimport { localizer } from './global-config';\nimport type {\n  EnumInit,\n  EnumKey,\n  EnumValue,\n  FindEnumKeyByValue,\n  ListItem,\n  PrimitiveOf,\n  ValueTypeFromSingleInit,\n} from './types';\nimport { ENUM_OPTIONS, IS_ENUM, ITEMS, KEYS, LABELS, META, NAMED, VALUES } from './utils';\n\n/**\n * - **EN:** Enum collection extension base class, used to extend the Enums\n * - **CN:** 枚举集合扩展基类，用于扩展枚举\n */\n// @ts-expect-error: because don't know which methods are added\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class EnumExtensionClass<\n  T extends EnumInit<K, V>,\n  K extends EnumKey<T> = EnumKey<T>,\n  V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n> implements EnumExtension<T, K, V> {}\n\n/**\n * - **EN:** Enum collection\n * - **CN:** 枚举项集合\n */\nexport class EnumCollectionClass<\n    const T extends EnumInit<K, V>,\n    K extends EnumKey<T> = EnumKey<T>,\n    V extends EnumValue = ValueTypeFromSingleInit<T[K], K>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const P = any,\n  >\n  extends EnumExtensionClass<T, K, V>\n  implements InheritableEnumItems<T, K, V, P>\n{\n  private readonly __options__: EnumInitOptions<T, K, V, P> | undefined;\n  // used for e2e serialization\n  private readonly __items__!: EnumItemsArray<T, K, V, P>;\n\n  constructor(init: T = {} as T, options?: EnumInitOptions<T, K, V, P>) {\n    super();\n    // Do not use class field here, because don't want print this field in Node.js\n    Object.defineProperty(this, '__options__', {\n      value: options,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    const keys = Object.keys(init) as K[];\n    // Generate enum items array\n    const items = new EnumItemsArray<T, K, V, P>(init, options);\n    Object.freeze(items);\n    // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken\n    this[keys.includes('items') ? ITEMS : 'items'] = items;\n    Object.defineProperty(this, '__items__', {\n      value: items,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // @ts-expect-error: because use KEYS to avoid naming conflicts in case of 'keys' field name is taken\n    this[keys.includes('keys') ? KEYS : 'keys'] = items[KEYS];\n\n    // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken\n    this[keys.includes('values') ? VALUES : 'values'] = items[VALUES];\n\n    // @ts-expect-error: because use NAMED to avoid naming conflicts in case of 'named' field name is taken\n    this[keys.includes('named') ? NAMED : 'named'] = items.named;\n\n    // @ts-expect-error: because use META to avoid naming conflicts in case of 'meta' field name is taken\n    this[keys.includes('meta') ? META : 'meta'] = items.meta;\n\n    // Add keys to the instance, allows picking enum values by keys\n    items.forEach((item) => {\n      // @ts-expect-error: because of dynamic property\n      this[item.key] = item.value;\n    });\n\n    // @ts-expect-error: because use LABELS to avoid naming conflicts in case of 'labels' field name is taken\n    Object.defineProperty(this, keys.includes('labels') ? LABELS : 'labels', {\n      enumerable: true,\n      configurable: false,\n      get: function (this: EnumCollectionClass<T, K, V, P>) {\n        return this.__items__.labels;\n      },\n    });\n\n    Object.freeze(this);\n  }\n  /**\n   * - **EN:** A boolean value indicates that this is an enum collection instance.\n   * - **CN:** 布尔值，表示这是一个枚举集合实例\n   */\n  // Do not use readonly field here, because don't want print this field in Node.js\n  // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n  get [IS_ENUM](): true {\n    return true;\n  }\n  /**\n   * - **EN:** Get the options to initialize the enum.\n   * - **CN:** 获取初始化枚举时的选项\n   */\n  get [ENUM_OPTIONS](): EnumItemOptions<T[K], K, V, P> | undefined {\n    return this.__options__;\n  }\n  [Symbol.hasInstance]<T>(instance: T): instance is Extract<T, K | V> {\n    return instance instanceof this.__items__;\n  }\n  /**\n   * The enum collection name, supports localization. Note that it usually returns a string, but if\n   * a custom `localize` function is set, the return value may vary depending on the implementation\n   * of the method.\n   *\n   * - **CN:** 枚举集合显示名称，支持本地化。注意，通常情况下返回的是字符串，但如果设置了自定义的 `localize` 函数，则返回值可能有所不同，取决于方法的实现\n   *\n   * @returns {string | undefined} The localized name of the enum collection, or undefined if not\n   *   set.\n   */\n  get name(): string | undefined {\n    if (typeof this.__options__?.name === 'function') {\n      return this.__options__.name(undefined!);\n    }\n    const localize = this.__options__?.localize ?? localizer.localize;\n    if (typeof localize === 'function') {\n      return localize(this.__options__?.name);\n    }\n    return this.__options__?.name;\n  }\n\n  label<KV extends V | K | NonNullable<PrimitiveOf<V>> | NonNullable<PrimitiveOf<K>> | undefined>(keyOrValue: KV) {\n    return this.__items__.label(keyOrValue);\n  }\n\n  key<IV extends V | NonNullable<PrimitiveOf<V>> | undefined>(value?: IV) {\n    return this.__items__.key(value);\n  }\n\n  raw(): T;\n  raw<IK extends V | K | Exclude<EnumValue, string> | NonNullable<string>>(\n    keyOrValue: IK\n  ): IK extends K ? T[IK] : IK extends V ? T[FindEnumKeyByValue<T, IK>] : T[K] | undefined;\n  raw<IK extends EnumValue>(value?: IK | unknown): T | T[K] | T[FindEnumKeyByValue<T, IK>] | undefined {\n    if (value != null) {\n      return this.__items__.raw(value as keyof T | EnumValue) as T[K];\n    } else {\n      return this.__items__.raw();\n    }\n  }\n\n  has<KV>(keyOrValue?: KV): keyOrValue is Extract<KV, K | V> {\n    return this.__items__.has(keyOrValue);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  findBy(...rest: Parameters<EnumItemsArray<T, K, V, P>['findBy']>): any {\n    return this.__items__.findBy(...rest);\n  }\n\n  toList(): ListItem<V, 'value', 'label'>[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ): ListItem<\n    V,\n    FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n    FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n  >[];\n  toList<\n    FOV extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n    FOL extends string | ((item: EnumItemClass<T[K], K, V, P>) => string),\n  >(\n    config?: ToListConfig<T, FOV, FOL, K, V, never, P>\n  ):\n    | ListItem<V, 'value', 'label'>[]\n    | ListItem<\n        V,\n        FOV extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOV,\n        FOL extends (item: EnumItemClass<T[K], K, V, P>) => infer R ? R : FOL\n      >[] {\n    return this.__items__.toList(config as ToListConfig<T, FOV, FOL, K, V, never, P>);\n  }\n\n  toMap(): MapResult<T, 'value', 'label', K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P>;\n  toMap<\n    KS extends EnumItemFields | (<R extends string | symbol>(item: EnumItemClass<T[K], K, V, P>) => R),\n    VS extends EnumItemFields | (<R>(item: EnumItemClass<T[K], K, V, P>) => R),\n  >(config?: ToMapConfig<T, KS, VS, K, V, P>): MapResult<T, KS, VS, K, V, P> {\n    return this.__items__.toMap(config as ToMapConfig<T, KS, VS, K, V, P>);\n  }\n\n  get valueType() {\n    return this.__items__.valueType;\n  }\n  get keyType() {\n    return this.__items__.keyType;\n  }\n  get rawType() {\n    return this.__items__.rawType;\n  }\n}\n"],"mappings":"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"}